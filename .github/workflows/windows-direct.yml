name: Native Windows Build and Test

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
  workflow_call:

permissions:
  contents: read

jobs:
  build-and-test-windows:
    name: Build and Test on Windows (vcpkg + clang-cl + sccache + Ninja)
    runs-on: windows-latest
    env:
      # optional: customize sccache cache directory
      SCCACHE_DIR: ${{ runner.temp }}\.sccache
      # optional: increase sccache cache size (example)
      SCCACHE_CACHE_SIZE: 5G

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: "73af4de996897cb45dcf5034d16a551a3cf476f7"

      - name: Install dependencies via vcpkg (manifest or explicit)
        run: |
          # manifest mode (recommended) -- installs packages for x64-windows
          vcpkg install --triplet x64-windows
        shell: pwsh

      # -------------------------
      # Install sccache (via cargo). If you already have sccache in PATH,
      # replace/remove these steps.
      - name: Install Rust (for cargo) (required to install sccache)
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Install sccache with cargo
        run: |
          cargo install sccache --locked
        shell: pwsh

      - name: Ensure cargo bin is on PATH
        run: |
          $cargoBin = "$env:USERPROFILE\.cargo\bin"
          Write-Host "Adding $cargoBin to PATH for this job"
          $env:PATH = "$cargoBin;$env:PATH"
          Write-Host "PATH now: $env:PATH"
        shell: pwsh

      # optional: cache the sccache on-disk cache between runs (improves warm-start)
      - name: Cache sccache disk cache
        uses: actions/cache@v4
        with:
          path: ${{ env.SCCACHE_DIR }}
          # key can be tuned; using OS + repo head short hash keeps it specific
          key: sccache-${{ runner.os }}-${{ hashFiles('**/*') }}
          restore-keys: |
            sccache-${{ runner.os }}-

      # -------------------------
      # Prepare Visual Studio environment so clang-cl can find link.exe, SDK headers, etc.
      # This runs VsDevCmd.bat (found via vswhere) to set up environment variables.
      - name: Initialize Visual Studio build environment
        shell: pwsh
        run: |
          $vswhere = "${{ envProgramFiles(x86) }}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            Write-Host "vswhere not at expected path, searching common location..."
            $vswhere = "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"
          }

          if (-not (Test-Path $vswhere)) {
            throw "vswhere.exe not found; cannot initialize VS environment"
          }

          $installationPath = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
          if (-not $installationPath) { throw "Could not find Visual Studio installation path via vswhere" }

          Write-Host "Found Visual Studio at: $installationPath"

          # Call VsDevCmd.bat to set environment for x64 builds.
          # The batch sets environment variables for the current cmd/powershell session when invoked via cmd /c and captured then re-exported.
          $vsDevCmd = Join-Path $installationPath 'Common7\Tools\VsDevCmd.bat'
          Write-Host "Calling: $vsDevCmd -arch=amd64"
          # We capture the environment set by VsDevCmd and import into PowerShell session
          $envoutput = cmd /c "`"$vsDevCmd`" -arch=amd64 && set"
          foreach ($line in $envoutput -split "`r?`n") {
            if ($line -match "^(.*?)=(.*)$") {
              $name = $matches[1]
              $value = $matches[2]
              # update PowerShell environment for later steps in the same job
              $env:$name = $value
            }
          }

          Write-Host "Visual Studio environment initialized."

      # -------------------------
      # Configure CMake: use Ninja and sccache as compiler launcher
      - name: Configure CMake with clang-cl + Ninja + sccache
        shell: pwsh
        run: |
          # Ensure clang-cl is the chosen compiler
          $clang = "C:\Program Files\LLVM\bin\clang-cl.exe"
          if (-not (Test-Path $clang)) {
            Write-Host "Warning: clang-cl not found at $clang. Adjust path if needed."
          }

          cmake -B build `
            -S . `
            -G "Ninja" `
            -A x64 `
            -DCMAKE_C_COMPILER="$clang" `
            -DCMAKE_CXX_COMPILER="$clang" `
            -DCMAKE_C_COMPILER_LAUNCHER="sccache" `
            -DCMAKE_CXX_COMPILER_LAUNCHER="sccache" `
            -DCMAKE_TOOLCHAIN_FILE="${env:VCPKG_ROOT}\scripts\buildsystems\vcpkg.cmake" `
            -DCMAKE_BUILD_TYPE=Release `
            -DBUILD_TESTS=ON
        env:
          # ensure sccache is found by CMake
          PATH: ${{ env.USERPROFILE }}\.cargo\bin;${{ env.PATH }}

      - name: Show sccache stats (before build)
        shell: pwsh
        run: |
          if (Get-Command sccache -ErrorAction SilentlyContinue) {
            sccache --show-stats || true
            sccache --show-config || true
          } else {
            Write-Host "sccache not available in PATH"
          }

      # -------------------------
      # Build project (Ninja via CMake) - Ninja will call sccache which will cache compilations
      - name: Build project (Ninja via CMake)
        shell: pwsh
        run: |
          # --parallel lets cmake choose reasonable parallelism (or you can pass a number)
          cmake --build build --config Release --parallel

      - name: Show sccache stats (after build)
        shell: pwsh
        run: |
          if (Get-Command sccache -ErrorAction SilentlyContinue) {
            sccache --show-stats || true
          }

      - name: List build outputs (debug)
        run: |
          Write-Host "=== Test Executables ==="
          Get-ChildItem -Path "build/tests/Release" -Filter *.exe | ForEach-Object { 
            Write-Host "$($_. FullName) - $($_.Length) bytes"
          }

          Write-Host "`n=== Core DLLs ==="
          Get-ChildItem -Path "build/Release" -Filter *.dll | ForEach-Object { 
            Write-Host "$($_.Name)"
          }

          Write-Host "`n=== Vcpkg DLLs ==="
          Get-ChildItem -Path "build/vcpkg_installed/x64-windows/bin" -Filter *.dll | Select-Object -First 20 | ForEach-Object { 
            Write-Host "$($_.Name)"
          }
        shell: pwsh

      - name: Run unit tests
        run: |
          # CRITICAL: Add DLL directories to PATH
          $env:PATH = "$PWD/build/vcpkg_installed/x64-windows/bin;$PWD/build/Release;$env:PATH"

          $testPath = "build/tests/Release/unit_tests.exe"

          if (Test-Path $testPath) {
            Write-Host "Running unit tests..."
            Write-Host "Executable: $testPath"
            Write-Host "Working Directory: $(Get-Location)"
            
            # Run test and capture output
            & $testPath 2>&1 | Tee-Object -Variable testOutput
            $exitCode = $LASTEXITCODE
            
            Write-Host "`nTest process exit code: $exitCode"
            
            # Check for common Windows DLL errors
            if ($exitCode -eq -1073741515 -or $exitCode -eq 3221225781) {
              Write-Error "DLL NOT FOUND ERROR (0xC0000135)"
              Write-Host "The test executable cannot find required DLLs."
              Write-Host "Check that these directories are in PATH:"
              Write-Host "  - build/vcpkg_installed/x64-windows/bin"
              Write-Host "  - build/Release"
              exit 1
            }
            
            if ($exitCode -ne 0) {
              Write-Error "Unit tests failed with exit code $exitCode"
              exit $exitCode
            }
            
            Write-Host "✓ Unit tests passed successfully"
          } else {
            Write-Error "unit_tests.exe not found at: $testPath"
            exit 1
          }
        shell: pwsh

      - name: Run integration tests
        run: |
          # CRITICAL: Add DLL directories to PATH
          $env:PATH = "$PWD/build/vcpkg_installed/x64-windows/bin;$PWD/build/Release;$env:PATH"

          $testPath = "build/tests/Release/integration_tests.exe"

          if (Test-Path $testPath) {
            Write-Host "Running integration tests..."
            
            & $testPath 2>&1 | Tee-Object -Variable testOutput
            $exitCode = $LASTEXITCODE
            
            Write-Host "`nTest process exit code: $exitCode"
            
            if ($exitCode -eq -1073741515 -or $exitCode -eq 3221225781) {
              Write-Error "DLL NOT FOUND ERROR (0xC0000135)"
              exit 1
            }
            
            if ($exitCode -ne 0) {
              Write-Error "Integration tests failed with exit code $exitCode"
              exit $exitCode
            }
            
            Write-Host "✓ Integration tests passed successfully"
          } else {
            Write-Error "integration_tests.exe not found at: $testPath"
            exit 1
          }
        shell: pwsh

      - name: Collect artifacts
        run: |
          New-Item -ItemType Directory -Force -Path windows-binaries
          Copy-Item -Path "LICENSE" -Destination "windows-binaries/" -ErrorAction SilentlyContinue
          Get-ChildItem -Path "build" -Recurse -Include *.exe,*.dll | Copy-Item -Destination "windows-binaries/" -ErrorAction SilentlyContinue
          Get-ChildItem -Path "windows-binaries"
        shell: pwsh

      - name: Upload Windows binaries
        uses: actions/upload-artifact@v4
        with:
          name: windows-binaries
          path: windows-binaries/
          retention-days: 7

      - name: Setup tmate session for debugging (on failure)
        if: ${{ failure() }}
        uses: mxschmitt/action-tmate@v3
        timeout-minutes: 30
        with:
          limit-access-to-actor: true

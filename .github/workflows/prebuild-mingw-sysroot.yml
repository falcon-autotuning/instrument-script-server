name: Prebuild â€” mingw sysroot (create prebuilt tarball & push to GHCR with oras)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 3 * * 0" # weekly (UTC)

permissions:
  contents: read
  packages: write

jobs:
  prebuild-mingw-sysroot:
    name: Build mingw sysroot and upload to GHCR
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: >-
        -v /home/runner/work/instrument-script-server/instrument-script-server:/workspace
    env:
      SYSROOT_TARBALL_PATH: /tmp/mingw-sysroot.tar.gz
      WORKSPACE: /workspace
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Restore pacman cache
        uses: actions/cache@v4
        with:
          path: /var/cache/pacman/pkg
          key: ${{ runner.os }}-pacman-cache-v1

      - name: Prepare pacman keys and install base packages (including tmate)
        run: |
          set -euo pipefail
          rm -rf /etc/pacman.d/gnupg || true
          pacman-key --init || true
          pacman-key --populate archlinux
          # Install minimal host packages and common build deps + tmate for debugging
          pacman -Syu --noconfirm --needed base-devel git mingw-w64-gcc cmake ninja curl jq go sudo tar findutils tmate

      - name: Create builder user
        run: |
          set -euo pipefail
          useradd -m -s /bin/bash builder || true
          mkdir -p /home/builder
          chown -R builder:builder /home/builder
          chown -R builder:builder /workspace || true

      - name: Restore yay cache
        uses: actions/cache@v4
        with:
          path: |
            /home/builder/.cache/yay
            /home/builder/yay/pkg
          key: ${{ runner.os }}-yay-cache-v1

      - name: Create safe sudoers for builder (no heredoc)
        run: |
          set -euo pipefail
          rm -f /etc/sudoers.d/builder
          # Use printf to avoid heredoc/indentation issues in YAML blocks
          printf '%s\n' 'builder ALL=(ALL) NOPASSWD: /usr/bin/pacman' > /etc/sudoers.d/builder
          chmod 0440 /etc/sudoers.d/builder
          # Validate syntax; this will fail the job if the file is invalid
          visudo -cf /etc/sudoers.d/builder

      - name: Build yay and install AUR mingw packages as builder
        run: |
          set -euo pipefail
          runuser -u builder -- bash -lc '
            set -euo pipefail
            cd "$HOME"
            if [ ! -d "$HOME/yay" ]; then
              git clone https://aur.archlinux.org/yay.git
            fi
            cd yay
            makepkg -si --noconfirm
            AUR_PKGS=(
              mingw-w64-cmake
              mingw-w64-lua
              mingw-w64-luajit
              mingw-w64-spdlog
              mingw-w64-boost
              mingw-w64-nlohmann-json
              mingw-w64-yaml-cpp
              mingw-w64-gtest
            )
            for p in "${AUR_PKGS[@]}"; do
              echo "Installing AUR pkg: $p"
              yay -S --noconfirm --mflags --skipinteg "$p"
            done
          '

      - name: Ensure sol2 headers (header-only)
        run: |
          set -euo pipefail
          git clone --depth 1 --branch v3.3.0 https://github.com/ThePhD/sol2.git /tmp/sol2 || true
          mkdir -p /usr/x86_64-w64-mingw32/include/sol
          cp -r /tmp/sol2/include/sol/* /usr/x86_64-w64-mingw32/include/sol/ || true
          chown -R root:root /usr/x86_64-w64-mingw32/include/sol || true

      - name: Create tarball of mingw sysroot
        run: |
          set -euo pipefail
          if [ ! -d /usr/x86_64-w64-mingw32 ]; then
            echo "ERROR: expected /usr/x86_64-w64-mingw32 to exist but it does not"
            ls -la /usr || true
            exit 1
          fi
          tar -C / -czf "${SYSROOT_TARBALL_PATH}" usr/x86_64-w64-mingw32
          echo "Tarball size:"
          ls -lh "${SYSROOT_TARBALL_PATH}"
          echo "Tarball contents preview (first 50 lines):"
          tar -tf "${SYSROOT_TARBALL_PATH}" > /tmp/mingw-tar-list.txt
          head -n 50 /tmp/mingw-tar-list.txt

      - name: Upload tarball as workflow artifact (backup)
        uses: actions/upload-artifact@v4
        with:
          name: mingw-sysroot-tarball
          path: /tmp/mingw-sysroot.tar.gz

      - name: Install oras (OCI registry client) - robust via GitHub API
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/oras-project/oras/releases/latest"
          echo "Querying ORAS releases via $API"
          ASSET_URL=$(curl -sSL "$API" | jq -r '.assets[] | select(.name | test("linux.*(amd64|x86_64)|amd64.*linux|x86_64.*linux"; "i")) | .browser_download_url' | head -n1)
          if [ -z "${ASSET_URL:-}" ] || [ "${ASSET_URL}" = "null" ]; then
            echo "Failed to find a Linux amd64 ORAS asset in latest release"
            echo "Release JSON:"
            curl -sSL "$API" | jq -C .
            exit 1
          fi
          echo "Found ORAS asset: ${ASSET_URL}"
          curl -fsSL -o /tmp/oras.tar.gz "${ASSET_URL}"
          mkdir -p /tmp/oras-install
          tar -xzf /tmp/oras.tar.gz -C /tmp/oras-install
          ORAS_BIN=$(find /tmp/oras-install -type f -name 'oras' -perm /a+x | head -n1 || true)
          if [ -z "${ORAS_BIN}" ]; then
            ORAS_BIN=$(find /tmp/oras-install -type f -name 'oras' | head -n1 || true)
          fi
          if [ -z "${ORAS_BIN}" ]; then
            echo "oras binary not found in extracted archive:"
            ls -la /tmp/oras-install || true
            exit 1
          fi
          install -m 0755 "${ORAS_BIN}" /usr/local/bin/oras
          echo "oras installed at /usr/local/bin/oras"
          /usr/local/bin/oras version || true

      - name: Login to GHCR (using GITHUB_TOKEN)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${GITHUB_TOKEN:-}" ]; then
            echo "GITHUB_TOKEN not available; ensure workflow permissions allow packages: write"
            exit 1
          fi
          echo "${GITHUB_TOKEN}" | oras login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin

      - name: Push mingw sysroot to GHCR (versioned + latest)
        id: push_oras
        run: |
          set -euo pipefail
          REGISTRY="ghcr.io"
          REPO="${{ github.repository_owner }}/mingw-sysroot"
          VERSION_TAG="run-${GITHUB_RUN_ID}"
          VERSION_REF="${REGISTRY}/${REPO}:${VERSION_TAG}"
          LATEST_REF="${REGISTRY}/${REPO}:latest"
          echo "Pushing versioned artifact ${VERSION_REF}"
          # Allow absolute path here intentionally (oras path validation blocks absolute paths by default)
          oras push "${VERSION_REF}" /tmp/mingw-sysroot.tar.gz --artifact-type application/vnd.tar+gzip --disable-path-validation
          echo "Pushing latest artifact ${LATEST_REF}"
          oras push "${LATEST_REF}" /tmp/mingw-sysroot.tar.gz --artifact-type application/vnd.tar+gzip --disable-path-validation
          echo "version_ref=${VERSION_REF}" >> $GITHUB_OUTPUT
          echo "latest_ref=${LATEST_REF}" >> $GITHUB_OUTPUT

      - name: Done (print refs)
        run: |
          echo "Uploaded OCI artifact refs:"
          echo "version_ref = ${{ steps.push_oras.outputs.version_ref }}"
          echo "latest_ref  = ${{ steps.push_oras.outputs.latest_ref }}"

      - name: Start tmate session for debugging on failure
        if: ${{ failure() }}
        run: |
          set -euo pipefail
          # tmate should already be installed via pacman above; ensure it's present
          if ! command -v tmate >/dev/null 2>&1; then
            pacman -S --noconfirm tmate || true
          fi
          # Start a detached tmate session and print connection info
          TMATE_SOCK=/tmp/tmate.sock
          tmate -S "${TMATE_SOCK}" new-session -d
          tmate -S "${TMATE_SOCK}" wait tmate-ready
          echo "===== TMATE CONNECTION INFO ====="
          tmate -S "${TMATE_SOCK}" display -p '#{tmate_ssh}'
          tmate -S "${TMATE_SOCK}" display -p '#{tmate_web}'
          echo "================================="
          # Keep session alive so you can connect; job will time out eventually according to workflow/job timeout
          # Sleep in a loop to be robust to signals
          while true; do sleep 60; done

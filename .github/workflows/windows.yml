name: Cross-Compile Windows on Arch and Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      PREBUILT_REF:
        description: "OCI reference for the prebuilt mingw sysroot (e.g., ghcr.io/OWNER/mingw-sysroot:latest). If empty, defaults to ghcr.io/<owner>/mingw-sysroot:latest"
        required: false
        default: ""
  workflow_call:

permissions:
  contents: read
  packages: read

jobs:
  cross-build-windows:
    name: Build Windows cross (use prebuilt mingw sysroot from GHCR)
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: >-
        -v /home/runner/work/instrument-script-server/instrument-script-server:/workspace
    env:
      WORKSPACE: /workspace
      BUILD_DIR: /workspace/build
      PACMAN_CACHE_KEY: pacman-archlinux-v1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Restore pacman cache
        uses: actions/cache@v4
        with:
          path: /var/cache/pacman/pkg
          key: ${{ runner.os }}-${{ env.PACMAN_CACHE_KEY }}
          restore-keys: |
            ${{ runner.os }}-${{ env.PACMAN_CACHE_KEY }}-

      - name: Prepare pacman keys and install host tools (including tmate)
        run: |
          set -euo pipefail
          rm -rf /etc/pacman.d/gnupg || true
          pacman-key --init || true
          pacman-key --populate archlinux
          pacman -Syu --noconfirm --needed \
            base-devel \
            git \
            mingw-w64-gcc \
            cmake \
            ninja \
            curl \
            jq \
            tar \
            tmate

      - name: Install oras (OCI registry client)
        run: |
          set -euo pipefail
          # Resolve the linux/amd64 asset URL for the latest ORAS release via the GitHub Releases API
          ASSET_URL=$(curl -sSL "https://api.github.com/repos/oras-project/oras/releases/latest" \
            | jq -r '.assets[] | select(.name | test("linux.*(amd64|x86_64)|amd64.*linux|x86_64.*linux"; "i")) | .browser_download_url' \
            | head -n1)
          if [ -z "${ASSET_URL:-}" ] || [ "${ASSET_URL}" = "null" ]; then
            echo "Failed to find a Linux amd64 ORAS asset in latest release"
            curl -sSL "https://api.github.com/repos/oras-project/oras/releases/latest" | jq -C .
            exit 1
          fi
          echo "Downloading ORAS from: ${ASSET_URL}"
          curl -fsSL -o /tmp/oras.tar.gz "${ASSET_URL}"
          mkdir -p /tmp/oras-install
          tar -xzf /tmp/oras.tar.gz -C /tmp/oras-install
          ORAS_BIN=$(find /tmp/oras-install -type f -name 'oras' -perm /a+x | head -n1 || true)
          if [ -z "${ORAS_BIN}" ]; then
            ORAS_BIN=$(find /tmp/oras-install -type f -name 'oras' | head -n1 || true)
          fi
          if [ -z "${ORAS_BIN}" ]; then
            echo "oras binary not found in extracted archive:"
            ls -la /tmp/oras-install || true
            exit 1
          fi
          install -m 0755 "${ORAS_BIN}" /usr/local/bin/oras
          chmod +x /usr/local/bin/oras || true
          /usr/local/bin/oras version || true

      - name: Login to GHCR (using GITHUB_TOKEN if needed)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${GITHUB_TOKEN:-}" ]; then
            echo "${GITHUB_TOKEN}" | oras login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin
          else
            echo "No GITHUB_TOKEN available; attempting unauthenticated pull (artifact must be public)."
          fi

      - name: Pull & extract prebuilt mingw sysroot from GHCR
        # Support both workflow_dispatch and reusable workflow calls:
        env:
          INPUT_PREBUILT: ${{ inputs.PREBUILT_REF }}
          EVENT_PREBUILT: ${{ github.event.inputs.PREBUILT_REF }}
        run: |
          set -euo pipefail
          # Prefer explicit inputs (reusable workflow inputs or workflow_dispatch inputs)
          if [ -n "${INPUT_PREBUILT:-}" ]; then
            REF="${INPUT_PREBUILT}"
          elif [ -n "${EVENT_PREBUILT:-}" ]; then
            REF="${EVENT_PREBUILT}"
          else
            REF="ghcr.io/${GITHUB_REPOSITORY_OWNER}/mingw-sysroot:latest"
          fi
          echo "Using prebuilt sysroot reference: ${REF}"
          mkdir -p /tmp/oras-out
          cd /tmp/oras-out
          # Pull the artifact into the working directory, allowing path traversal
          # (our ORAS artifact may contain an absolute path like /tmp/mingw-sysroot.tar.gz)
          oras pull --allow-path-traversal "${REF}" || {
            echo "oras pull failed for ${REF}"
            exit 1
          }
          # The artifact producer may write the tarball to an absolute path (e.g. /tmp/...).
          # Look for the tarball in the current dir and /tmp and normalize to /tmp/mingw-sysroot.tar.gz
          TARFILE=$(ls -1 *.tar.gz 2>/dev/null || true)
          if [ -z "${TARFILE}" ]; then
            TARFILE=$(ls -1 *.tgz 2>/dev/null || true)
          fi
          if [ -z "${TARFILE}" ]; then
            TARFILE=$(ls -1 *.tar 2>/dev/null || true)
          fi
          if [ -z "${TARFILE}" ]; then
            # fallback: check /tmp for tarballs written by ORAS with absolute paths
            TARFILE=$(ls -1 /tmp/*.tar.gz 2>/dev/null || true)
          fi
          if [ -z "${TARFILE}" ]; then
            echo "ERROR: no tarball (.tar.gz/.tgz/.tar) found after oras pull"
            ls -la /tmp/oras-out || true
            ls -la /tmp || true
            exit 1
          fi
          TARFILE=$(printf '%s\n' ${TARFILE} | head -n1)
          echo "Found tarball: ${TARFILE}"
          mv "${TARFILE}" /tmp/mingw-sysroot.tar.gz || true
          echo "Extracting mingw sysroot to / (expecting usr/x86_64-w64-mingw32/...)"
          tar -xzf /tmp/mingw-sysroot.tar.gz -C /
          echo "Resulting sysroot path listing:"
          ls -la /usr/x86_64-w64-mingw32 || true

      - name: Create builder user and set permissions
        run: |
          set -euo pipefail
          useradd -m -s /bin/bash builder || true
          mkdir -p /home/builder
          chown -R builder:builder /home/builder
          chown -R builder:builder /workspace || true

      - name: Configure & build (cmake + ninja) as builder
        run: |
          set -euo pipefail
          mkdir -p "${BUILD_DIR}"
          cd "${BUILD_DIR}"
          runuser -u builder -- bash -lc '
            set -euo pipefail
            cd /workspace || exit 1
            mkdir -p build
            cd build
            cmake -G Ninja \
              -DCMAKE_SYSTEM_NAME=Windows \
              -DCMAKE_C_COMPILER=x86_64-w64-mingw32-gcc \
              -DCMAKE_CXX_COMPILER=x86_64-w64-mingw32-g++ \
              -DCMAKE_BUILD_TYPE=Release \
              -DBUILD_TESTS=ON \
              ..
            ninja -v
          '

      - name: Collect windows-binaries artifact
        run: |
          set -euo pipefail
          mkdir -p /workspace/windows-binaries
          cd /workspace/build || exit 0
          cp instrument-server.exe /workspace/windows-binaries/ 2>/dev/null || true
          cp instrument-worker.exe /workspace/windows-binaries/ 2>/dev/null || true
          cp libinstrument-server-core.dll /workspace/windows-binaries/ 2>/dev/null || true
          cp ../LICENSE /workspace/windows-binaries/ 2>/dev/null || true
          cp tests/unit_tests.exe /workspace/windows-binaries/ 2>/dev/null || true
          cp tests/integration_tests.exe /workspace/windows-binaries/ 2>/dev/null || true
          ls -la /workspace/windows-binaries || true

      - name: Upload windows binaries artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-binaries
          path: /workspace/windows-binaries
          retention-days: 7

      - name: Start tmate session for debugging on failure
        if: ${{ failure() }}
        run: |
          set -euo pipefail
          # tmate is installed earlier via pacman. Ensure it's available.
          if ! command -v tmate >/dev/null 2>&1; then
            pacman -S --noconfirm tmate || true
          fi
          TMATE_SOCK=/tmp/tmate.sock
          tmate -S "${TMATE_SOCK}" new-session -d
          tmate -S "${TMATE_SOCK}" wait tmate-ready
          echo "===== TMATE CONNECTION INFO ====="
          tmate -S "${TMATE_SOCK}" display -p '#{tmate_ssh}'
          tmate -S "${TMATE_SOCK}" display -p '#{tmate_web}'
          echo "================================="
          # Keep session alive so you can connect; job will time out per workflow/job timeout
          while true; do sleep 60; done

  test-on-windows:
    name: Test built Windows artifacts
    runs-on: windows-latest
    needs: cross-build-windows
    permissions:
      contents: read
    steps:
      - name: Download Windows binaries
        uses: actions/download-artifact@v4
        with:
          name: windows-binaries
          path: windows-binaries

      - name: Run unit tests (cmd)
        shell: cmd
        run: |
          cd windows-binaries
          echo Running unit tests...
          if exist unit_tests.exe (
            .\unit_tests.exe
            echo ✓ Unit tests passed successfully
          ) else (
            echo No unit_tests.exe found
          )

      - name: Run integration tests (cmd)
        shell: cmd
        run: |
          cd windows-binaries
          echo Running integration tests...
          if exist integration_tests.exe (
            .\integration_tests.exe
            echo ✓ Integration tests passed successfully
          ) else (
            echo No integration_tests.exe found
          )

      - name: List packaged files
        shell: cmd
        run: |
          cd windows-binaries
          dir

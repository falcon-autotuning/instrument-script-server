name: Cross-Compile Windows on Arch and Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      PREBUILT_REF:
        description: "OCI reference for the prebuilt mingw sysroot (e.g., ghcr.io/OWNER/mingw-sysroot:latest). If empty, defaults to ghcr.io/<owner>/mingw-sysroot:latest"
        required: false
        default: ""
  workflow_call:

permissions:
  contents: read
  packages: read

jobs:
  cross-build-windows:
    name: Build Windows cross (use prebuilt mingw sysroot from GHCR, clang)
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: >-
        -v /home/runner/work/instrument-script-server/instrument-script-server:/workspace
    env:
      WORKSPACE: /workspace
      BUILD_DIR: /workspace/build
      PACMAN_CACHE_KEY: pacman-archlinux-v1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Restore pacman cache
        uses: actions/cache@v4
        with:
          path: /var/cache/pacman/pkg
          key: ${{ runner.os }}-${{ env.PACMAN_CACHE_KEY }}
          restore-keys: |
            ${{ runner.os }}-${{ env.PACMAN_CACHE_KEY }}-

      - name: Prepare pacman keys and install host tools (including clang, lld, tmate)
        run: |
          set -euo pipefail
          rm -rf /etc/pacman.d/gnupg || true
          pacman-key --init || true
          pacman-key --populate archlinux
          pacman -Syu --noconfirm --needed \
            base-devel \
            git \
            mingw-w64-gcc \
            cmake \
            ninja \
            curl \
            jq \
            tar \
            clang \
            lld \
            tmate

      - name: Install oras (OCI registry client) - robust via GitHub API
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/oras-project/oras/releases/latest"
          echo "Querying ORAS releases via $API"
          ASSET_URL=$(curl -sSL "$API" | jq -r '.assets[] | select(.name | test("linux.*(amd64|x86_64)|amd64.*linux|x86_64.*linux"; "i")) | .browser_download_url' | head -n1)
          if [ -z "${ASSET_URL:-}" ] || [ "${ASSET_URL}" = "null" ]; then
            echo "Failed to find a Linux amd64 ORAS asset in latest release"
            echo "Release JSON:"
            curl -sSL "$API" | jq -C .
            exit 1
          fi
          echo "Found ORAS asset: ${ASSET_URL}"
          curl -fsSL -o /tmp/oras.tar.gz "${ASSET_URL}"
          mkdir -p /tmp/oras-install
          tar -xzf /tmp/oras.tar.gz -C /tmp/oras-install
          ORAS_BIN=$(find /tmp/oras-install -type f -name 'oras' -perm /a+x | head -n1 || true)
          if [ -z "${ORAS_BIN}" ]; then
            ORAS_BIN=$(find /tmp/oras-install -type f -name 'oras' | head -n1 || true)
          fi
          if [ -z "${ORAS_BIN}" ]; then
            echo "oras binary not found in extracted archive:"
            ls -la /tmp/oras-install || true
            exit 1
          fi
          install -m 0755 "${ORAS_BIN}" /usr/local/bin/oras
          chmod +x /usr/local/bin/oras || true
          /usr/local/bin/oras version || true

      - name: Login to GHCR (using GITHUB_TOKEN if needed)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${GITHUB_TOKEN:-}" ]; then
            echo "${GITHUB_TOKEN}" | oras login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin
          else
            echo "No GITHUB_TOKEN available; attempting unauthenticated pull (artifact must be public)."
          fi

      - name: Pull & extract prebuilt mingw sysroot from GHCR
        env:
          INPUT_PREBUILT: ${{ inputs.PREBUILT_REF }}
          EVENT_PREBUILT: ${{ github.event.inputs.PREBUILT_REF }}
        run: |
          set -euo pipefail
          if [ -n "${INPUT_PREBUILT:-}" ]; then
            REF="${INPUT_PREBUILT}"
          elif [ -n "${EVENT_PREBUILT:-}" ]; then
            REF="${EVENT_PREBUILT}"
          else
            REF="ghcr.io/${GITHUB_REPOSITORY_OWNER}/mingw-sysroot:latest"
          fi
          echo "Using prebuilt sysroot reference: ${REF}"
          mkdir -p /tmp/oras-out
          cd /tmp/oras-out
          # artifact may contain absolute paths; allow traversal
          oras pull --allow-path-traversal "${REF}" || { echo "oras pull failed for ${REF}"; exit 1; }
          # find tarball either here or in /tmp (some pushes used absolute path)
          TARFILE=$(ls -1 *.tar.gz 2>/dev/null || true)
          if [ -z "${TARFILE}" ]; then TARFILE=$(ls -1 *.tgz 2>/dev/null || true); fi
          if [ -z "${TARFILE}" ]; then TARFILE=$(ls -1 *.tar 2>/dev/null || true); fi
          if [ -z "${TARFILE}" ]; then TARFILE=$(ls -1 /tmp/*.tar.gz 2>/dev/null || true); fi
          if [ -z "${TARFILE}" ]; then echo "ERROR: no tarball found after oras pull"; ls -la /tmp/oras-out || true; ls -la /tmp || true; exit 1; fi
          TARFILE=$(printf '%s\n' ${TARFILE} | head -n1)
          echo "Found tarball: ${TARFILE}"
          mv "${TARFILE}" /tmp/mingw-sysroot.tar.gz || true
          echo "Inspecting tarball contents (top entries):"
          tar -tzf /tmp/mingw-sysroot.tar.gz | sed -n '1,40p' || true
          echo "Extracting mingw sysroot to / (expecting usr/x86_64-w64-mingw32/...)"
          tar -xzf /tmp/mingw-sysroot.tar.gz -C /
          echo "Resulting sysroot path listing:"
          ls -la /usr/x86_64-w64-mingw32 || true

      - name: Create builder user and ensure build dir ownership
        run: |
          set -euo pipefail
          useradd -m -s /bin/bash builder || true
          mkdir -p /home/builder
          chown -R builder:builder /home/builder
          # create build dir and ensure builder owns it (do not chown whole workspace)
          mkdir -p "${BUILD_DIR}"
          chown -R builder:builder "${BUILD_DIR}" || true
          chmod -R u+rwX "${BUILD_DIR}" || true

      - name: Write clang->mingw CMake toolchain file
        run: |
          set -euo pipefail
          cat > /tmp/mingw-clang-toolchain.cmake <<'EOF'
          # clang -> mingw-w64 sysroot toolchain for x86_64-w64-mingw32
          set(CMAKE_SYSTEM_NAME Windows)
          set(CMAKE_SYSTEM_VERSION 1)
          set(CMAKE_C_COMPILER clang)
          set(CMAKE_CXX_COMPILER clang++)
          set(CMAKE_SYSROOT /usr/x86_64-w64-mingw32)
          set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
          # Prefer the sysroot for libs/includes; do not search host paths for programs
          set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
          set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
          # clang flags
          set(CLANG_TARGET "--target=x86_64-w64-mingw32")
          set(CLANG_SYSROOT "--sysroot=${CMAKE_SYSROOT}")
          set(CMAKE_C_FLAGS "${CLANG_TARGET} ${CLANG_SYSROOT} ${CMAKE_C_FLAGS}")
          set(CMAKE_CXX_FLAGS "${CLANG_TARGET} ${CLANG_SYSROOT} ${CMAKE_CXX_FLAGS}")
          # If libgcc/libgcc_eh are installed under /usr (pacman), add that libdir so lld can find libgcc.
          # Adjust this path if your distribution uses a version subdirectory (e.g. /usr/lib/gcc/x86_64-w64-mingw32/15/)
          set(MINGW_GCC_LIBDIR "/usr/lib/gcc/x86_64-w64-mingw32")
          set(CMAKE_EXE_LINKER_FLAGS "${CLANG_TARGET} ${CLANG_SYSROOT} -fuse-ld=lld -L${MINGW_GCC_LIBDIR} ${CMAKE_EXE_LINKER_FLAGS}")
          set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS}")
          EOF
          chmod 0644 /tmp/mingw-clang-toolchain.cmake
          echo "Wrote toolchain file to /tmp/mingw-clang-toolchain.cmake"

      - name: Configure & build with clang (cmake + ninja) as builder
        run: |
          set -euo pipefail
          # ensure build dir exists (owned by builder)
          mkdir -p "${BUILD_DIR}"
          chown -R builder:builder "${BUILD_DIR}" || true
          runuser -u builder -- bash -lc '
            set -euo pipefail
            # Configure with CMake toolchain for clang -> mingw
            cmake -S /workspace -B "${BUILD_DIR}" -G Ninja \
              -DCMAKE_TOOLCHAIN_FILE=/tmp/mingw-clang-toolchain.cmake \
              -DCMAKE_BUILD_TYPE=Release \
              -DBUILD_TESTS=ON
            cmake --build "${BUILD_DIR}" -- -v
          '

      - name: Collect windows-binaries artifact
        run: |
          set -euo pipefail
          mkdir -p /workspace/windows-binaries
          cd /workspace || exit 0
          # Copy likely outputs from build dir
          find "${BUILD_DIR}" -maxdepth 6 -type f \( -iname '*.exe' -o -iname '*.dll' \) -exec cp -t /workspace/windows-binaries {} + || true
          cp LICENSE /workspace/windows-binaries/ 2>/dev/null || true
          ls -la /workspace/windows-binaries || true

      - name: Upload windows binaries artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-binaries
          path: /workspace/windows-binaries
          retention-days: 7

      - name: Start tmate session for debugging on failure
        if: ${{ failure() }}
        run: |
          set -euo pipefail
          if ! command -v tmate >/dev/null 2>&1; then pacman -S --noconfirm tmate || true; fi
          TMATE_SOCK=/tmp/tmate.sock
          tmate -S "${TMATE_SOCK}" new-session -d
          tmate -S "${TMATE_SOCK}" wait tmate-ready
          echo "===== TMATE CONNECTION INFO ====="
          tmate -S "${TMATE_SOCK}" display -p '#{tmate_ssh}'
          tmate -S "${TMATE_SOCK}" display -p '#{tmate_web}'
          echo "================================="
          while true; do sleep 60; done

  test-on-windows:
    name: Test built Windows artifacts
    runs-on: windows-latest
    needs: cross-build-windows
    permissions:
      contents: read
    steps:
      - name: Download Windows binaries
        uses: actions/download-artifact@v4
        with:
          name: windows-binaries
          path: windows-binaries

      - name: Run unit tests (cmd)
        shell: cmd
        run: |
          cd windows-binaries
          echo Running unit tests...
          if exist unit_tests.exe (
            .\unit_tests.exe
            echo ✓ Unit tests passed successfully
          ) else (
            echo No unit_tests.exe found
          )

      - name: Run integration tests (cmd)
        shell: cmd
        run: |
          cd windows-binaries
          echo Running integration tests...
          if exist integration_tests.exe (
            .\integration_tests.exe
            echo ✓ Integration tests passed successfully
          ) else (
            echo No integration_tests.exe found
          )

      - name: List packaged files
        shell: cmd
        run: |
          cd windows-binaries
          dir

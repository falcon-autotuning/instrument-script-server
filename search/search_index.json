{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Instrument Script Server","text":"<p>A modular, process-isolated system for controlling scientific instruments for laboratory automation.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Process Isolation: Each instrument runs in a separate worker process for fault tolerance</li> <li>Plugin Architecture: Instrument drivers as loadable plugins (VISA, serial, custom SDKs)</li> <li>Lua Scripting: High-level measurement scripts with runtime contexts</li> <li>Automatic Result Collection: All command return values are automatically captured with full traceability</li> <li>Synchronization:  Parallel execution with precise timing coordination across instruments</li> <li>Cross-Platform: Works on Linux and Windows</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>The Instrument Script Server is designed for high-performance laboratory automation with minimal overhead:</p>"},{"location":"#end-to-end-performance-best-case","title":"End-to-End Performance (Best Case)","text":"<ul> <li>Average Command Latency: ~200 \u00b5s per command</li> <li>Throughput: ~5,000 commands/second</li> <li>IPC Throughput: 400,000+ messages/second</li> <li>Sync Barrier Overhead: &lt;4 \u00b5s per synchronization point</li> </ul>"},{"location":"#scalability","title":"Scalability","text":"<ul> <li>Concurrent Instruments: Supports 10+ instruments simultaneously</li> <li>Multi-instrument Commands: 200 \u00b5s average latency with 10 concurrent instruments</li> <li>Setup Time: ~500 ms per additional instrument</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Single instrument control: ~200 \u00b5s overhead per command</li> <li>Complex measurements with parameters: ~220 \u00b5s overhead</li> <li>Array/large data transfers: ~220 \u00b5s overhead</li> <li>Multi-instrument parallel execution: Linear scaling up to 10+ instruments</li> </ul> <p>These benchmarks were measured on a standard development machine and represent typical performance. Actual performance may vary based on hardware, instrument drivers, and measurement complexity.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Build and install\nmake build\nsudo cmake --install .\n\n# Start the server daemon\ninstrument-server daemon start\n\n# Start instruments (customize configs with your instruments)\ninstrument-server start configs/instrument1.yaml\ninstrument-server start configs/instrument2.yaml\n\n# Run a measurement\ninstrument-server measure my_measurement.lua\n\n# Run with JSON output for programmatic parsing\ninstrument-server measure my_measurement.lua --json\n\n# Check status\ninstrument-server list\n\n# Shutdown\ninstrument-server daemon stop\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Find it here.</p> <ul> <li>Configuration Guide - How to write instrument configurations and API definitions</li> <li>CLI Usage - Complete command-line interface reference</li> <li>Plugin Development - Creating custom instrument drivers</li> <li>Architecture - System design and components</li> <li>Synchronization - Parallel execution protocol</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#dependencies","title":"Dependencies","text":"<p>Required:</p> <ul> <li>CMake 3.20+</li> <li>C++17 compiler</li> <li>Lua 5.3+ or LuaJIT</li> <li>sol2 (Lua C++ bindings)</li> <li>spdlog (logging)</li> <li>nlohmann_json (JSON parsing)</li> <li>yaml-cpp (YAML parsing)</li> <li>Google Test (for testing)</li> </ul> <p>Optional:</p> <ul> <li>NI-VISA (for VISA instruments)</li> </ul>"},{"location":"#build","title":"Build","text":"<pre><code>git clone https://github.com/falcon-autotuning/instrument-script-server.git\ncd instrument-script-server\nmake build\nsudo cmake --install .\n</code></pre>"},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code>instrument-server --help\ninstrument-server plugins\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Configuration files are located in the <code>examples/</code> folder:</p> <ul> <li>examples/instrument-configurations/ - Sample instrument configurations</li> <li>examples/instrument-apis/ - Sample API definitions</li> <li>examples/scripts/ - Sample measurement scripts</li> </ul> <p>See the Configuration Guide for detailed information on the JSON schema.</p>"},{"location":"#example-workflow","title":"Example Workflow","text":"<pre><code># 1. Start the daemon\ninstrument-server daemon start\n\n# 2. Start your instruments (modify example configs with your connection details)\ninstrument-server start examples/instrument-configurations/agi_34401_config.yaml\ninstrument-server start examples/instrument-configurations/dso9254a_config.yaml\n\n# 3. Write and run a measurement script\ncat &gt; simple_measurement.lua &lt;&lt; 'EOF'\n-- Set voltage and measure\ncontext: call(\"INSTRUMENT_NAME.SET_VOLTAGE\", {voltage = 5.0})\nlocal result = context:call(\"INSTRUMENT_NAME.MEASURE_VOLTAGE\")\nprint(\"Measured:  \" .. result ..  \" V\")\nEOF\n\ninstrument-server measure simple_measurement.lua\n\n# 4. Check status\ninstrument-server list\ninstrument-server status INSTRUMENT_NAME\n\n# 5. Stop when done\ninstrument-server daemon stop\n</code></pre>"},{"location":"#built-in-validation-tools","title":"Built-in Validation Tools","text":"<p>The server includes built-in configuration validation:</p> <pre><code># Validate an instrument configuration\ninstrument-server validate config examples/instrument-configurations/agi_34401_config.yaml\n\n# Validate an API definition\ninstrument-server validate api examples/instrument-apis/agi_34401a. yaml\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>cd build\n\n# Run specific test categories\nmake test_unit           # Fast unit tests\nmake test_integration    # Integration tests\nmake test_perf          # Performance benchmarks\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see our contribution guidelines.</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE for details.</p>"},{"location":"ARCHITECTURE/","title":"Instrument Server Architecture","text":"<p>Detailed technical documentation of the system architecture, components, and design decisions.</p>"},{"location":"ARCHITECTURE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Instrument Server Architecture</li> <li>Table of Contents</li> <li>System Overview<ul> <li>Key Design Principles</li> </ul> </li> <li>Process Model<ul> <li>Server Daemon Process</li> <li>Worker Processes</li> <li>Command Processes</li> </ul> </li> <li>Core Components<ul> <li>ServerDaemon</li> <li>InstrumentRegistry</li> <li>InstrumentWorkerProxy</li> <li>SyncCoordinator</li> </ul> </li> <li>IPC Communication<ul> <li>Transport:  Shared Memory Queues</li> <li>Message Format</li> <li>Serialization</li> </ul> </li> <li>Synchronization System<ul> <li>Protocol Overview</li> <li>Timing Guarantees</li> </ul> </li> <li>Plugin System<ul> <li>Plugin Interface</li> <li>Plugin Loader</li> <li>Plugin Registry</li> </ul> </li> <li>Configuration System<ul> <li>Instrument Configuration</li> <li>API Definition</li> </ul> </li> <li>Data Flow<ul> <li>Command Execution Flow</li> <li>Parallel Execution Flow</li> </ul> </li> <li>Error Handling<ul> <li>Worker Death</li> <li>Command Timeout</li> <li>Sync Timeout</li> <li>Plugin Error</li> </ul> </li> <li>Performance Characteristics<ul> <li>Latency Measurements</li> <li>Throughput</li> <li>Scalability</li> <li>Optimization Opportunities</li> </ul> </li> <li>Platform-Specific Details<ul> <li>Linux</li> <li>Windows</li> </ul> </li> <li>Future Enhancements<ul> <li>Hot Reload</li> <li>Web Interface</li> </ul> </li> <li>See Also</li> </ul>"},{"location":"ARCHITECTURE/#system-overview","title":"System Overview","text":"<p>The Instrument Server uses a multi-process, daemon-based architecture with IPC for communication and synchronization.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      User Commands                            \u2502\n\u2502  instrument-server start/stop/measure/...                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Server Daemon Process                       \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 ServerDaemon                                             \u2502 \u2502\n\u2502  \u2502  - Lifecycle management                                  \u2502 \u2502\n\u2502  \u2502  - PID file handling                                     \u2502 \u2502\n\u2502  \u2502  - Signal handling                                       \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 InstrumentRegistry                                       \u2502 \u2502\n\u2502  \u2502  - Tracks all instruments                                \u2502 \u2502\n\u2502  \u2502  - Creates InstrumentWorkerProxy per instrument          \u2502 \u2502\n\u2502  \u2502  - Manages worker lifecycles                             \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 SyncCoordinator                                          \u2502 \u2502\n\u2502  \u2502  - Manages sync barriers                                 \u2502 \u2502\n\u2502  \u2502  - Tracks ACKs from workers                              \u2502 \u2502\n\u2502  \u2502  - Broadcasts SYNC_CONTINUE                              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 InstrumentWorkerProxy (per instrument)                   \u2502 \u2502\n\u2502  \u2502  - IPC client                                            \u2502 \u2502\n\u2502  \u2502  - Command serialization                                 \u2502 \u2502\n\u2502  \u2502  - Response handling                                     \u2502 \u2502\n\u2502  \u2502  - Heartbeat monitoring                                  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193 Shared Memory IPC\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Worker Processes                           \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502 instrument-  \u2502  \u2502 instrument-  \u2502  \u2502 instrument-  \u2502         \u2502\n\u2502  \u2502 worker       \u2502  \u2502 worker       \u2502  \u2502 worker       \u2502         \u2502\n\u2502  \u2502 (DMM1)       \u2502  \u2502 (DAC1)       \u2502  \u2502 (Scope1)     \u2502         \u2502\n\u2502  \u2502              \u2502  \u2502              \u2502  \u2502              \u2502         \u2502\n\u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u2502\n\u2502  \u2502 \u2502 Plugin   \u2502 \u2502  \u2502 \u2502 Plugin   \u2502 \u2502  \u2502 \u2502 Plugin   \u2502 \u2502         \u2502\n\u2502  \u2502 \u2502 Loader   \u2502 \u2502  \u2502 \u2502 Loader   \u2502 \u2502  \u2502 \u2502 Loader   \u2502 \u2502         \u2502\n\u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Hardware Layer                             \u2502\n\u2502  VISA \u2022 Serial \u2022 USB \u2022 Network \u2022 Native SDKs                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ARCHITECTURE/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Process Isolation: Each instrument runs in separate process - crashes don't affect others</li> <li>Daemon Model: Long-lived background process manages state</li> <li>IPC Communication: Fast shared memory queues for message passing</li> <li>Plugin Architecture: Instrument drivers as loadable modules</li> <li>Synchronization: Precise timing coordination via barrier protocol</li> </ol>"},{"location":"ARCHITECTURE/#process-model","title":"Process Model","text":""},{"location":"ARCHITECTURE/#server-daemon-process","title":"Server Daemon Process","text":"<p>Purpose: Long-lived background process managing all state</p> <p>Responsibilities:</p> <ul> <li>Maintain InstrumentRegistry</li> <li>Coordinate SyncBarriers</li> <li>Handle user commands (via new invocations)</li> <li>Monitor worker health</li> </ul> <p>Lifecycle:</p> <pre><code>daemon start \u2192 Create PID file \u2192 Initialize Registry \u2192 Event loop\n                                                         \u2193\ndaemon stop  \u2190 Cleanup IPC \u2190 Stop all workers \u2190 Signal handling\n</code></pre> <p>Implementation:  <code>src/server/ServerDaemon.cpp</code></p>"},{"location":"ARCHITECTURE/#worker-processes","title":"Worker Processes","text":"<p>Purpose: Isolated execution environment for each instrument</p> <p>Responsibilities:</p> <ul> <li>Load and initialize plugin</li> <li>Execute commands from IPC queue</li> <li>Send heartbeats</li> <li>Handle sync protocol</li> </ul> <p>Lifecycle:</p> <pre><code>registry.create_instrument() \u2192 fork() \u2192 load plugin \u2192 IPC loop\n                                                        \u2193\nregistry.remove_instrument() \u2190 cleanup \u2190 shutdown \u2190 SIGTERM\n</code></pre> <p>Implementation: <code>src/workers/generic_worker_main.cpp</code></p>"},{"location":"ARCHITECTURE/#command-processes","title":"Command Processes","text":"<p>Purpose: Short-lived processes for user commands</p> <p>Responsibilities:</p> <ul> <li>Parse command-line arguments</li> <li>Connect to daemon via registry</li> <li>Execute command</li> <li>Return result</li> </ul> <p>Lifecycle:</p> <pre><code>instrument-server &lt;cmd&gt; \u2192 Connect to registry \u2192 Execute \u2192 Exit\n</code></pre> <p>Implementation: <code>src/tools/instrument_server_main.cpp</code></p>"},{"location":"ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"ARCHITECTURE/#serverdaemon","title":"ServerDaemon","text":"<p>File: <code>src/server/ServerDaemon.cpp</code></p> <p>Key Methods:</p> <pre><code>bool start();                    // Start daemon\nvoid stop();                     // Stop daemon\nbool is_running() const;         // Check if running\nstatic bool is_already_running(); // Check for existing instance\nstatic int get_daemon_pid();     // Get PID of running daemon\n</code></pre> <p>State Management:</p> <ul> <li>PID file: <code>/tmp/instrument-server-$USER/server. pid</code> (Linux)</li> <li>PID file: <code>%LOCALAPPDATA%\\InstrumentServer\\server.pid</code> (Windows)</li> <li>Singleton pattern ensures one instance</li> </ul> <p>Thread Model:  Single-threaded event loop</p>"},{"location":"ARCHITECTURE/#instrumentregistry","title":"InstrumentRegistry","text":"<p>File: <code>src/server/InstrumentRegistry.cpp</code></p> <p>Key Methods:</p> <pre><code>bool create_instrument(const std::string &amp;config_path);\nstd::shared_ptr&lt;InstrumentWorkerProxy&gt; get_instrument(const std::string &amp;name);\nbool has_instrument(const std::string &amp;name) const;\nvoid remove_instrument(const std::string &amp;name);\nstd::vector&lt;std::string&gt; list_instruments() const;\nvoid stop_all();\n</code></pre> <p>Data Structures:</p> <pre><code>class InstrumentRegistry {\nprivate:\n  mutable std::mutex mutex_;\n  std::map&lt;std::string, std::shared_ptr&lt;InstrumentWorkerProxy&gt;&gt; instruments_;\n  SyncCoordinator sync_coordinator_;\n};\n</code></pre> <p>Thread Safety: All methods protected by mutex</p>"},{"location":"ARCHITECTURE/#instrumentworkerproxy","title":"InstrumentWorkerProxy","text":"<p>File: <code>src/server/InstrumentWorkerProxy.cpp</code></p> <p>Purpose: Client-side IPC proxy for each instrument</p> <p>Key Methods:</p> <pre><code>bool start();                                    // Spawn worker\nvoid stop();                                     // Stop worker\nstd::future&lt;CommandResponse&gt; execute(SerializedCommand cmd);\nCommandResponse execute_sync(SerializedCommand cmd, timeout);\nbool is_alive() const;                          // Check worker health\nvoid send_sync_continue(uint64_t sync_token);   // Sync protocol\n</code></pre> <p>Thread Model:</p> <ul> <li>Main thread: Command dispatch</li> <li>Response thread: IPC message listener</li> </ul> <p>State:</p> <pre><code>class InstrumentWorkerProxy {\nprivate:\n  std::unique_ptr&lt;ipc::SharedQueue&gt; ipc_queue_;\n  ipc::ProcessId worker_pid_;\n  std::unordered_map&lt;uint64_t, std:: promise&lt;CommandResponse&gt;&gt; pending_responses_;\n  std::thread response_thread_;\n  std:: atomic&lt;bool&gt; running_;\n};\n</code></pre>"},{"location":"ARCHITECTURE/#synccoordinator","title":"SyncCoordinator","text":"<p>File: <code>src/server/SyncCoordinator.cpp</code></p> <p>Purpose: Coordinate parallel execution across instruments</p> <p>Key Methods:</p> <pre><code>void register_barrier(uint64_t token, const std::vector&lt;std:: string&gt; &amp;instruments);\nbool handle_ack(uint64_t token, const std::string &amp;instrument);\nvoid clear_barrier(uint64_t token);\nstd::vector&lt;std::string&gt; get_waiting_instruments(uint64_t token) const;\n</code></pre> <p>Data Structures:</p> <pre><code>class SyncCoordinator {\nprivate:\n  struct SyncBarrier {\n    std::set&lt;std::string&gt; expected_instruments;\n    std::set&lt;std:: string&gt; acked_instruments;\n    std:: chrono::steady_clock::time_point created_at;\n  };\n\n  mutable std::mutex mutex_;\n  std::map&lt;uint64_t, SyncBarrier&gt; barriers_;\n};\n</code></pre> <p>See Also:  SYNCHRONIZATION.md</p>"},{"location":"ARCHITECTURE/#ipc-communication","title":"IPC Communication","text":""},{"location":"ARCHITECTURE/#transport-shared-memory-queues","title":"Transport:  Shared Memory Queues","text":"<p>Implementation: <code>src/ipc/SharedQueue.cpp</code></p> <p>Platform:</p> <ul> <li>Linux:  POSIX shared memory (<code>shm_open</code>, <code>mmap</code>)</li> <li>Windows: Named shared memory (<code>CreateFileMapping</code>, <code>MapViewOfFile</code>)</li> </ul> <p>Queue Structure:</p> <pre><code>struct SharedQueue {\n  // Ring buffer in shared memory\n  // Lock-free for single producer, single consumer\n  size_t head;\n  size_t tail;\n  IPCMessage messages[QUEUE_SIZE];\n};\n</code></pre>"},{"location":"ARCHITECTURE/#message-format","title":"Message Format","text":"<p>File: <code>include/instrument-server/ipc/IPCMessage.hpp</code></p> <pre><code>struct IPCMessage {\n  enum class Type :  uint32_t {\n    COMMAND = 1,\n    RESPONSE = 2,\n    HEARTBEAT = 3,\n    SHUTDOWN = 4,\n    SYNC_ACK = 5,\n    SYNC_CONTINUE = 6\n  };\n\n  Type type;\n  uint64_t id;           // Message ID\n  uint64_t sync_token;   // Synchronization group\n  uint32_t payload_size;\n  char payload[4096];    // Serialized command/response (JSON)\n};\n</code></pre>"},{"location":"ARCHITECTURE/#serialization","title":"Serialization","text":"<p>File: <code>src/SerializedCommand.cpp</code></p> <p>Commands and responses serialized as JSON:</p> <pre><code>std::string serialize_command(const SerializedCommand &amp;cmd);\nSerializedCommand deserialize_command(const std::string &amp;json);\n\nstd::string serialize_response(const CommandResponse &amp;resp);\nCommandResponse deserialize_response(const std::string &amp;json);\n</code></pre> <p>Format Example:</p> <pre><code>{\n  \"id\": \"DMM1-12345\",\n  \"instrument_name\": \"DMM1\",\n  \"verb\": \"MEASURE\",\n  \"expects_response\": true,\n  \"timeout_ms\": 5000,\n  \"sync_token\": 42,\n  \"params\": {\n    \"channel\": 1,\n    \"range\": \"AUTO\"\n  }\n}\n</code></pre>"},{"location":"ARCHITECTURE/#synchronization-system","title":"Synchronization System","text":"<p>Full details:  SYNCHRONIZATION.md</p>"},{"location":"ARCHITECTURE/#protocol-overview","title":"Protocol Overview","text":"<ol> <li>RuntimeContext detects <code>parallel()</code> block</li> <li>Commands buffered instead of immediate execution</li> <li>All commands tagged with same <code>sync_token</code></li> <li>SyncCoordinator registers barrier with participating instruments</li> <li>Commands dispatched to workers</li> <li>Workers execute, send RESPONSE, then SYNC_ACK</li> <li>Workers block until SYNC_CONTINUE received</li> <li>SyncCoordinator waits for all ACKs</li> <li>When complete, broadcasts SYNC_CONTINUE to all workers</li> <li>Workers unblock and proceed to next command</li> </ol>"},{"location":"ARCHITECTURE/#timing-guarantees","title":"Timing Guarantees","text":"<ul> <li>All instruments in parallel block complete before any advances</li> <li>No instrument can proceed past sync point until all ready</li> <li>Call blocks (sequential) execute on single instrument immediately</li> </ul>"},{"location":"ARCHITECTURE/#plugin-system","title":"Plugin System","text":"<p>Full details: PLUGIN_DEVELOPMENT.md</p>"},{"location":"ARCHITECTURE/#plugin-interface","title":"Plugin Interface","text":"<p>File: <code>include/instrument-server/plugin/PluginInterface.h</code></p> <pre><code>// Required exports\nPluginMetadata plugin_get_metadata(void);\nint32_t plugin_initialize(const PluginConfig *config);\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp);\nvoid plugin_shutdown(void);\n</code></pre>"},{"location":"ARCHITECTURE/#plugin-loader","title":"Plugin Loader","text":"<p>File: <code>src/plugin/PluginLoader. cpp</code></p> <pre><code>class PluginLoader {\npublic:\n  explicit PluginLoader(const std::string &amp;path);\n  bool is_loaded() const;\n  PluginMetadata get_metadata();\n  int32_t initialize(const PluginConfig &amp;config);\n  int32_t execute_command(const PluginCommand &amp;cmd, PluginResponse &amp;resp);\n  void shutdown();\n\nprivate:\n  void *handle_;  // dlopen/LoadLibrary handle\n  // Function pointers to plugin exports\n};\n</code></pre>"},{"location":"ARCHITECTURE/#plugin-registry","title":"Plugin Registry","text":"<p>File: <code>src/plugin/PluginRegistry.cpp</code></p> <p>Maps protocol types to plugin paths:</p> <pre><code>class PluginRegistry {\npublic:\n  void discover_plugins(const std::vector&lt;std::string&gt; &amp;search_paths);\n  void register_plugin(const std::string &amp;protocol, const std::string &amp;path);\n  std::string get_plugin_path(const std::string &amp;protocol) const;\n  std::vector&lt;std::string&gt; list_protocols() const;\n\nprivate:\n  std::map&lt;std::string, std::string&gt; plugins_; // protocol -&gt; path\n};\n</code></pre>"},{"location":"ARCHITECTURE/#configuration-system","title":"Configuration System","text":""},{"location":"ARCHITECTURE/#instrument-configuration","title":"Instrument Configuration","text":"<p>Format:  YAML</p> <pre><code>name: DMM1                    # Instrument instance name\napi_ref: apis/keithley.yaml    # API definition file\nconnection:\n  type:  VISA                  # Protocol type (maps to plugin)\n  address: \"TCPIP::192.168.1.100::INSTR\"\n  timeout: 5000\n</code></pre> <p>Loading: <code>InstrumentRegistry::create_instrument()</code></p> <ol> <li>Load instrument configuration YAML \u2192 JSON</li> <li>Resolve the <code>api_ref</code> and load the referenced API definition</li> <li>Resolution behavior:<ul> <li><code>file://</code> URIs are supported and treated as filesystem paths.</li> <li>Absolute paths are used directly.</li> <li>Relative paths are resolved preferentially relative to the instrument configuration file directory (the config file's parent directory). This allows a config and its API to be co-located and portable.</li> <li>If the config-relative candidate does not exist, the server falls back to resolving the relative path against the server process current working directory (cwd) for backward compatibility with existing server and test usage.</li> <li>The resolved path is canonicalized (normalized) before use; if the file is not found, instrument creation fails with a descriptive error showing the attempted config-relative path.</li> </ul> </li> <li>Extract protocol type from the API definition</li> <li>Lookup plugin for that protocol via PluginRegistry</li> <li>Create InstrumentWorkerProxy and pass the configuration and API definition</li> <li>Spawn worker with plugin path</li> </ol> <p>Example loading sequence:</p> <ul> <li>instrument-server processes <code>configs/dmm1.yaml</code></li> <li><code>dmm1.yaml</code> contains <code>api_ref: ../apis/keithley_2400.yaml</code></li> <li>The server resolves <code>../apis/keithley_2400.yaml</code> relative to <code>configs/</code> \u2192 <code>apis/keithley_2400.yaml</code> and loads that file</li> </ul>"},{"location":"ARCHITECTURE/#api-definition","title":"API Definition","text":"<p>Format:  YAML</p> <pre><code>protocol: \n  type:  VISA\n\ncommands:\n  MEASURE:\n    description: \"Measure DC voltage\"\n    template: \": MEAS:VOLT:DC?\"\n    response_type: double\n\n  SET_VOLTAGE:\n    description: \"Set output voltage\"\n    template: \": SOUR:VOLT {voltage}\"\n    params:\n      voltage: \n        type: double\n        required: true\n        min: -10.0\n        max: 10.0\n</code></pre> <p>Validation: <code>SchemaValidator</code> class validates against JSON schemas</p>"},{"location":"ARCHITECTURE/#data-flow","title":"Data Flow","text":""},{"location":"ARCHITECTURE/#command-execution-flow","title":"Command Execution Flow","text":"<pre><code>1.  Lua script:  context: call(\"DMM1.Measure\")\n      \u2193\n2. RuntimeContext. call()\n      \u2193\n3. RuntimeContext.send_command()\n      \u2193\n4. InstrumentRegistry.get_instrument(\"DMM1\")\n      \u2193\n5. InstrumentWorkerProxy.execute_sync()\n      \u2193\n6. serialize_command() \u2192 JSON\n      \u2193\n7. IPC:  Send to worker's queue\n      \u2193\n8. Worker: Receive from queue\n      \u2193\n9. deserialize_command() \u2192 SerializedCommand\n      \u2193\n10. Convert to PluginCommand\n      \u2193\n11. PluginLoader.execute_command()\n      \u2193\n12. Plugin: Actual hardware communication\n      \u2193\n13. PluginResponse \u2192 CommandResponse\n      \u2193\n14. serialize_response() \u2192 JSON\n      \u2193\n15. IPC: Send to server's queue\n      \u2193\n16. InstrumentWorkerProxy:  Receive response\n      \u2193\n17. deserialize_response() \u2192 CommandResponse\n      \u2193\n18. Fulfill promise/future\n      \u2193\n19. RuntimeContext:  Return to Lua\n</code></pre>"},{"location":"ARCHITECTURE/#parallel-execution-flow","title":"Parallel Execution Flow","text":"<pre><code>1. Lua: context:parallel(function() ... end)\n      \u2193\n2. RuntimeContext. parallel()\n   - Set in_parallel_block_ = true\n      \u2193\n3. Execute Lua block\n   - Each call() buffers command\n      \u2193\n4. RuntimeContext.execute_parallel_buffer()\n   - Generate sync_token\n   - Register barrier with SyncCoordinator\n      \u2193\n5. Dispatch all commands (with sync_token)\n      \u2193\n6. Workers execute commands\n      \u2193\n7. Workers send RESPONSE\n      \u2193\n8. Workers send SYNC_ACK\n      \u2193\n9. Workers BLOCK (wait for SYNC_CONTINUE)\n      \u2193\n10. SyncCoordinator: Collect ACKs\n      \u2193\n11. When all ACKed:  Broadcast SYNC_CONTINUE\n      \u2193\n12. Workers receive SYNC_CONTINUE\n      \u2193\n13. Workers unblock\n      \u2193\n14. parallel() returns to Lua\n</code></pre>"},{"location":"ARCHITECTURE/#error-handling","title":"Error Handling","text":""},{"location":"ARCHITECTURE/#worker-death","title":"Worker Death","text":"<pre><code>Worker process crashes/dies\n      \u2193\nHeartbeat timeout detected\n      \u2193\nInstrumentWorkerProxy.is_alive() \u2192 false\n      \u2193\nAll pending promises failed with \"Worker died\"\n      \u2193\nError propagated to user\n</code></pre>"},{"location":"ARCHITECTURE/#command-timeout","title":"Command Timeout","text":"<pre><code>Command sent to worker\n      \u2193\nfuture.wait_for(timeout)\n      \u2193\nTimeout expires\n      \u2193\nReturn CommandResponse{success=false, error=\"Timeout\"}\n</code></pre>"},{"location":"ARCHITECTURE/#sync-timeout","title":"Sync Timeout","text":"<pre><code>Sync barrier registered\n      \u2193\nNot all ACKs received within timeout\n      \u2193\nLog error with missing instruments\n      \u2193\nForce-complete barrier (broadcast SYNC_CONTINUE anyway)\n      \u2193\nPrevents deadlock, but results may be invalid\n</code></pre>"},{"location":"ARCHITECTURE/#plugin-error","title":"Plugin Error","text":"<pre><code>Plugin.execute_command() returns error\n      \u2193\nPluginResponse. success = false\n      \u2193\nCommandResponse.success = false\n      \u2193\nRuntimeContext.call() returns nil\n      \u2193\nLua script handles error\n</code></pre>"},{"location":"ARCHITECTURE/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"ARCHITECTURE/#latency-measurements","title":"Latency Measurements","text":"Operation Typical Time Notes IPC round-trip 200 \u00b5s Shared memory Command serialization 50 \u00b5s JSON encoding Sync coordination 500 \u00b5s Barrier overhead Plugin call 1-100 ms Hardware dependent"},{"location":"ARCHITECTURE/#throughput","title":"Throughput","text":"Scenario Rate Bottleneck Single command ~1000 cmd/s Instrument response Pipelined (queue depth 10) ~5000 cmd/s IPC + serialization Parallel (3 instruments) ~3000 cmd/s total Sync coordination"},{"location":"ARCHITECTURE/#scalability","title":"Scalability","text":"<ul> <li>Tested: 20 simultaneous instruments</li> <li>Memory: ~50 MB per worker process</li> <li>CPU:  Minimal (event-driven, mostly I/O wait)</li> <li>Limit: OS process limit, shared memory availability</li> </ul>"},{"location":"ARCHITECTURE/#optimization-opportunities","title":"Optimization Opportunities","text":"<ol> <li>Binary serialization instead of JSON (2-3x faster)</li> <li>Lock-free queues for IPC (10-20% improvement)</li> <li>Command batching (reduce IPC overhead)</li> <li>Thread pool for response handling (higher concurrency)</li> </ol>"},{"location":"ARCHITECTURE/#platform-specific-details","title":"Platform-Specific Details","text":""},{"location":"ARCHITECTURE/#linux","title":"Linux","text":"<ul> <li>IPC: POSIX shared memory (<code>/dev/shm/</code>)</li> <li>PID file: <code>/tmp/instrument-server-$USER/server.pid</code></li> <li>Process creation: <code>fork()</code> + <code>execl()</code></li> <li>Signals:  SIGTERM for graceful shutdown</li> </ul>"},{"location":"ARCHITECTURE/#windows","title":"Windows","text":"<ul> <li>IPC: Named shared memory (<code>Global\\instserver_*</code>)</li> <li>PID file: <code>%LOCALAPPDATA%\\InstrumentServer\\server.pid</code></li> <li>Process creation: <code>CreateProcess()</code></li> <li>Termination: <code>TerminateProcess()</code> with SIGTERM equivalent</li> </ul>"},{"location":"ARCHITECTURE/#future-enhancements","title":"Future Enhancements","text":""},{"location":"ARCHITECTURE/#hot-reload","title":"Hot Reload","text":"<p>Restart worker without interrupting others:</p> <pre><code>instrument-server reload DMM1\n</code></pre> <p>Implementation: Track worker state, spawn new worker, transfer state</p>"},{"location":"ARCHITECTURE/#web-interface","title":"Web Interface","text":"<p>HTTP API for remote control:</p> <pre><code>POST /api/instruments/start\nPOST /api/measurements/run\nGET  /api/instruments/status\n</code></pre> <p>Implementation: Embedded HTTP server in daemon</p>"},{"location":"ARCHITECTURE/#see-also","title":"See Also","text":"<ul> <li>CLI Usage - Command-line interface</li> <li>Plugin Development - Writing plugins</li> <li>Synchronization - Parallel execution details</li> <li>Main README - Getting started</li> </ul>"},{"location":"CLI_USAGE/","title":"Instrument Server CLI Usage Guide","text":"<p>Complete guide to using the <code>instrument-server</code> command-line interface.</p>"},{"location":"CLI_USAGE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Instrument Server CLI Usage Guide</li> <li>Table of Contents</li> <li>Overview<ul> <li>Command Categories</li> <li>Global Options</li> </ul> </li> <li>Daemon Management<ul> <li>Start Daemon</li> <li>Stop Daemon</li> <li>Check Daemon Status</li> </ul> </li> <li>Instrument Management<ul> <li>Start Instrument</li> <li>Stop Instrument</li> <li>Check Instrument Status</li> <li>List All Instruments</li> </ul> </li> <li>Measurements<ul> <li>Measure Command</li> <li>Script Structure</li> <li>Command Format</li> <li>Example Scripts</li> <li>Building Measurement Libraries</li> <li>Integration with Higher-Level Software</li> </ul> </li> <li>Testing<ul> <li>Test Command</li> </ul> </li> <li>Plugin Management<ul> <li>List Available Plugins</li> <li>Discover Plugins</li> </ul> </li> <li>Configuration Validation<ul> <li>Validate Command</li> </ul> </li> <li>Logging<ul> <li>Log Levels</li> <li>Log Files</li> <li>Viewing Logs</li> </ul> </li> <li>Complete Workflow Examples<ul> <li>Example 1: Basic Measurement</li> <li>Example 2: Development Workflow</li> <li>Example 3: Multi-Instrument Setup</li> <li>Example 4: Troubleshooting</li> </ul> </li> <li>Exit Codes</li> <li>Environment Variables</li> <li>See Also</li> </ul>"},{"location":"CLI_USAGE/#overview","title":"Overview","text":"<p>The <code>instrument-server</code> command provides a unified interface for all instrument server operations. All commands follow the pattern:</p> <pre><code>instrument-server &lt;command&gt; [subcommand] [options]\n</code></pre>"},{"location":"CLI_USAGE/#command-categories","title":"Command Categories","text":"Category Commands Description Daemon <code>daemon start/stop/status</code> Manage server daemon Instruments <code>start</code>, <code>stop</code>, <code>status</code>, <code>list</code> Manage instruments Measurements <code>measure &lt;script&gt;</code> Run measurement scripts Testing <code>test &lt;config&gt; &lt;verb&gt;</code> Test instrument commands Plugins <code>plugins</code>, <code>discover</code> Manage plugins Validation <code>validate config/api &lt;file&gt;</code> Validate configuration files"},{"location":"CLI_USAGE/#global-options","title":"Global Options","text":"<pre><code>--log-level &lt;level&gt;   Set logging level (debug|info|warn|error)\n--help, -h            Show help message\n</code></pre>"},{"location":"CLI_USAGE/#daemon-management","title":"Daemon Management","text":"<p>The server daemon is a background process that manages the instrument registry and coordinates all operations.</p>"},{"location":"CLI_USAGE/#start-daemon","title":"Start Daemon","text":"<pre><code>instrument-server daemon start [--log-level &lt;level&gt;]\n</code></pre> <p>Example:</p> <pre><code># Start with default logging (info)\ninstrument-server daemon start\n\n# Start with debug logging\ninstrument-server daemon start --log-level debug\n</code></pre> <p>Output:</p> <pre><code>Server daemon started (PID: 12345)\nDaemon running in background\n</code></pre> <p>Notes:</p> <ul> <li>Must be running before any instrument operations</li> <li>Only one daemon instance can run at a time</li> <li>Daemon persists until explicitly stopped</li> <li>On Linux:  PID file stored in <code>/tmp/instrument-server-$USER/server. pid</code></li> <li>On Windows: PID file stored in <code>%LOCALAPPDATA%\\InstrumentServer\\server.pid</code></li> </ul>"},{"location":"CLI_USAGE/#stop-daemon","title":"Stop Daemon","text":"<pre><code>instrument-server daemon stop\n</code></pre> <p>Example:</p> <pre><code>instrument-server daemon stop\n</code></pre> <p>Output:</p> <pre><code>Stopping server daemon (PID: 12345)...\nServer daemon stopped\n</code></pre> <p>Notes:</p> <ul> <li>Stops all running instruments gracefully</li> <li>Cleans up IPC resources</li> <li>Removes PID file</li> </ul>"},{"location":"CLI_USAGE/#check-daemon-status","title":"Check Daemon Status","text":"<pre><code>instrument-server daemon status\n</code></pre> <p>Example:</p> <pre><code>instrument-server daemon status\n</code></pre> <p>Output (if running):</p> <pre><code>Server daemon is running (PID: 12345)\nRuntime directory: /tmp/instrument-server-user/server. pid\n</code></pre> <p>Output (if not running):</p> <pre><code>Server daemon is not running\n</code></pre> <p>Exit codes:</p> <ul> <li><code>0</code>: Daemon is running</li> <li><code>1</code>: Daemon is not running</li> </ul>"},{"location":"CLI_USAGE/#instrument-management","title":"Instrument Management","text":""},{"location":"CLI_USAGE/#start-instrument","title":"Start Instrument","text":"<pre><code>instrument-server start &lt;config&gt; [--plugin &lt;path&gt;] [--log-level &lt;level&gt;]\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;config&gt;</code>: Path to instrument configuration YAML file</li> <li><code>--plugin &lt;path&gt;</code>: Optional custom plugin (. so on Linux, .dll on Windows)</li> <li><code>--log-level &lt;level&gt;</code>: Logging level (default: info)</li> </ul> <p>Examples:</p> <pre><code># Start instrument with discovered plugin\ninstrument-server start configs/dmm1.yaml\n\n# Start with custom plugin\ninstrument-server start configs/custom_instrument.yaml --plugin ./my_plugin.so\n\n# Start with debug logging\ninstrument-server start configs/dac1.yaml --log-level debug\n\n# Start multiple instruments\ninstrument-server start configs/dac1.yaml\ninstrument-server start configs/dac2.yaml\ninstrument-server start configs/dmm1.yaml\n</code></pre> <p>Output:</p> <pre><code>Started instrument:  DMM1\n</code></pre> <p>Requirements:</p> <ul> <li>Server daemon must be running</li> <li>Configuration file must exist and be valid</li> <li>Plugin for the protocol type must be available (unless --plugin specified)</li> </ul>"},{"location":"CLI_USAGE/#stop-instrument","title":"Stop Instrument","text":"<pre><code>instrument-server stop &lt;name&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;name&gt;</code>: Instrument name (from config file)</li> </ul> <p>Example:</p> <pre><code>instrument-server stop DMM1\n</code></pre> <p>Output:</p> <pre><code>Stopped instrument: DMM1\n</code></pre>"},{"location":"CLI_USAGE/#check-instrument-status","title":"Check Instrument Status","text":"<pre><code>instrument-server status &lt;name&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;name&gt;</code>: Instrument name</li> </ul> <p>Example:</p> <pre><code>instrument-server status DMM1\n</code></pre> <p>Output:</p> <pre><code>Instrument:  DMM1\n  Status:  RUNNING\n  Commands sent: 150\n  Commands completed: 148\n  Commands failed: 0\n  Commands timeout: 2\n</code></pre> <p>Status Fields:</p> <ul> <li>Status:  RUNNING or STOPPED</li> <li>Commands sent:  Total commands dispatched</li> <li>Commands completed: Successfully executed commands</li> <li>Commands failed: Commands that returned errors</li> <li>Commands timeout: Commands that exceeded timeout</li> </ul>"},{"location":"CLI_USAGE/#list-all-instruments","title":"List All Instruments","text":"<pre><code>instrument-server list\n</code></pre> <p>Example:</p> <pre><code>instrument-server list\n</code></pre> <p>Output:</p> <pre><code>Running instruments:\n  DAC1 [RUNNING]\n  DAC2 [RUNNING]\n  DMM1 [RUNNING]\n  Scope1 [STOPPED]\n</code></pre> <p>Notes:</p> <ul> <li>Shows all instruments registered with the daemon</li> <li><code>[RUNNING]</code>: Worker process is active</li> <li><code>[STOPPED]</code>: Worker process has died or been stopped</li> </ul>"},{"location":"CLI_USAGE/#measurements","title":"Measurements","text":"<p>Run Lua measurement scripts that control running instruments.</p>"},{"location":"CLI_USAGE/#measure-command","title":"Measure Command","text":"<pre><code>instrument-server measure &lt;script&gt; [--json] [--log-level &lt;level&gt;]\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;script&gt;</code>: Path to Lua measurement script</li> <li><code>--json</code>: Output results in JSON format (default: text format)</li> <li><code>--log-level &lt;level&gt;</code>: Logging level (default: info)</li> </ul> <p>Requirements:</p> <ul> <li>Server daemon must be running</li> <li>Required instruments must be started</li> <li>Script file must exist and be valid Lua</li> </ul> <p>Examples:</p> <pre><code># Run measurement script with text output\ninstrument-server measure scripts/iv_curve.lua\n\n# Get results in JSON format for programmatic parsing\ninstrument-server measure scripts/iv_curve.lua --json\n\n# With debug logging\ninstrument-server measure scripts/test.lua --log-level debug\n\n# Save JSON output to file\ninstrument-server measure scripts/sweep.lua --json &gt; results.json\n</code></pre>"},{"location":"CLI_USAGE/#automatic-result-collection","title":"Automatic Result Collection","text":"<p>All <code>context:call()</code> operations are automatically collected with full metadata, including: - Command ID and execution timestamp - Instrument name and verb (command) - Parameters passed to the command - Return value and type - Large data buffer references (for waveforms, arrays, etc.)</p> <p>Results are displayed after script execution in execution order, providing complete traceability of all measurements.</p>"},{"location":"CLI_USAGE/#text-output-format","title":"Text Output Format","text":"<p>By default, results are displayed in a human-readable format:</p> <pre><code>Running measurement...\nMeasurement complete\n\n=== Script Results ===\n[0] MockInstrument1:1.SET(5.0) -&gt; [bool] true\n[1] MockInstrument1:2.SET(3.0) -&gt; [bool] true\n[2] MockInstrument1:1.GET() -&gt; [double] 5.0\n[3] MockInstrument1:2.GET() -&gt; [double] 3.0\n[4] Scope1.CAPTURE() -&gt; [buffer] buf_abc123 (10000 elements, float32)\n======================\n</code></pre> <p>Each line shows: - Index: Sequential number of the call - Instrument and Command: Full command with channel if applicable - Parameters: Values passed to the command - Return Value: Type in brackets, followed by the value</p> <p>For large data buffers (waveforms, large arrays), the output shows a reference with: - buffer_id: Unique identifier for accessing the data - element_count: Number of data points - data_type: Type of data (float32, float64, int32, etc.)</p>"},{"location":"CLI_USAGE/#json-output-format","title":"JSON Output Format","text":"<p>Use <code>--json</code> flag to get structured output for automation and data processing:</p> <pre><code>instrument-server measure script.lua --json\n</code></pre> <p>Output structure:</p> <pre><code>{\n  \"status\": \"success\",\n  \"script\": \"iv_curve.lua\",\n  \"results\": [\n    {\n      \"index\": 0,\n      \"instrument\": \"MockInstrument1:1\",\n      \"verb\": \"SET\",\n      \"params\": {\"value\": 5.0},\n      \"executed_at_ms\": 1704720615123,\n      \"return\": {\n        \"type\": \"bool\",\n        \"value\": true\n      }\n    },\n    {\n      \"index\": 4,\n      \"instrument\": \"Scope1\",\n      \"verb\": \"CAPTURE\",\n      \"params\": {},\n      \"executed_at_ms\": 1704720615127,\n      \"return\": {\n        \"type\": \"buffer\",\n        \"buffer_id\": \"buf_abc123\",\n        \"element_count\": 10000,\n        \"data_type\": \"float32\"\n      }\n    }\n  ]\n}\n</code></pre> <p>JSON Schema: The output conforms to the JSON schema at <code>schemas/measurement_results.schema.json</code> for validation and automated parsing.</p> <p>Return Types: - <code>double</code>: Floating-point number - <code>int64</code>: Integer value - <code>string</code>: Text value - <code>bool</code>: Boolean (true/false) - <code>array</code>: Array of numbers - <code>buffer</code>: Reference to large data buffer - <code>void</code>: Command with no return value</p>"},{"location":"CLI_USAGE/#script-structure","title":"Script Structure","text":"<p>All scripts have access to a global <code>context</code> object:</p> <pre><code>-- context: call(command, args...)     - Execute instrument command\n-- context:parallel(function)         - Synchronized parallel execution\n-- context:log(message)               - Log message\n\ncontext:log(\"Script starting\")\n\n-- Your measurement logic here\nlocal value = context:call(\"DMM1.Measure\")\nprint(value)\n\ncontext:log(\"Script complete\")\n</code></pre>"},{"location":"CLI_USAGE/#command-format","title":"Command Format","text":"<pre><code>-- Basic:  InstrumentName.CommandVerb\ncontext:call(\"DAC1.SetVoltage\", 5.0)\n\n-- With channel:  InstrumentName: Channel.CommandVerb\ncontext:call(\"DAC1:1.SetVoltage\", 3.3)\n\n-- Return value\nlocal voltage = context:call(\"DMM1.MeasureVoltage\")\n</code></pre>"},{"location":"CLI_USAGE/#example-scripts","title":"Example Scripts","text":"<p>Simple sweep:</p> <pre><code>for v = 0, 5, 0.1 do\n    context:call(\"DAC1.Set\", v)\n    local i = context:call(\"DMM1.Measure\")\n    print(string.format(\"%. 3f,%. 6e\", v, i))\nend\n</code></pre> <p>Parallel execution:</p> <pre><code>context:parallel(function()\n    context:call(\"DAC1.Set\", 1.0)\n    context:call(\"DAC2.Set\", 2.0)\nend)\n-- Both DACs set simultaneously\n</code></pre> <p>2D measurement:</p> <pre><code>for x = 0, 10 do\n    context:call(\"DAC_X.Set\", x * 0.1)\n\n    for y = 0, 10 do\n        context:parallel(function()\n            context:call(\"DAC_Y.Set\", y * 0.05)\n        end)\n\n        local z = context:call(\"DMM1.Measure\")\n        print(string.format(\"%d,%d,%.6e\", x, y, z))\n    end\nend\n</code></pre>"},{"location":"CLI_USAGE/#building-measurement-libraries","title":"Building Measurement Libraries","text":"<p>Create reusable Lua modules for common measurement patterns:</p> <pre><code># Directory structure\nmeasurements/\n\u251c\u2500\u2500 dc_sweep.lua\n\u251c\u2500\u2500 waveform_1d.lua\n\u2514\u2500\u2500 stability_diagram.lua\n</code></pre> <pre><code>-- measurements/dc_sweep.lua\nlocal M = {}\n\nfunction M.sweep(setter, getter, v_start, v_stop, v_step)\n    local data = {}\n    local v = v_start\n\n    while v &lt;= v_stop do\n        context:call(setter, v)\n        os.execute(\"sleep 0.01\")\n        local measured = context:call(getter)\n        table.insert(data, {v, measured})\n        v = v + v_step\n    end\n\n    return data\nend\n\nreturn M\n</code></pre> <p>Use it:</p> <pre><code>package.path = package.path .. \";./measurements/?. lua\"\nlocal dc_sweep = require(\"dc_sweep\")\n\nlocal results = dc_sweep.sweep(\"DAC1.SetVoltage\", \"DMM1.Measure\", 0, 5, 0.1)\n\nfor _, point in ipairs(results) do\n    print(string.format(\"%. 3f,%.6e\", point[1], point[2]))\nend\n</code></pre>"},{"location":"CLI_USAGE/#integration-with-higher-level-software","title":"Integration with Higher-Level Software","text":"<p>The generic <code>measure</code> command allows integration with any high-level software:</p> <p>Python example:</p> <pre><code>import subprocess\nimport tempfile\n\n# Generate Lua script\nlua_script = \"\"\"\ncontext:log(\"Starting measurement\")\nfor v = 0, 5, 0.1 do\n    context:call(\"DAC1.Set\", v)\n    local i = context:call(\"DMM1.Measure\")\n    print(string.format(\"%.3f,%.6e\", v, i))\nend\n\"\"\"\n\n# Write to temp file\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.lua', delete=False) as f:\n    f.write(lua_script)\n    script_path = f.name\n\n# Run measurement\nresult = subprocess.run(\n    ['instrument-server', 'measure', script_path],\n    capture_output=True,\n    text=True\n)\n\n# Parse results\nfor line in result.stdout.split('\\n'):\n    if line.strip():\n        voltage, current = map(float, line.split(','))\n        print(f\"V={voltage}V, I={current}A\")\n</code></pre> <p>This architecture keeps the instrument server simple and generic, while allowing arbitrarily complex measurement logic in higher-level frameworks!</p>"},{"location":"CLI_USAGE/#testing","title":"Testing","text":"<p>Test individual instrument commands without writing full scripts.</p>"},{"location":"CLI_USAGE/#test-command","title":"Test Command","text":"<pre><code>instrument-server test &lt;config&gt; &lt;verb&gt; [param=value ... ] [--plugin &lt;path&gt;] [--log-level &lt;level&gt;]\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;config&gt;</code>: Path to instrument configuration file</li> <li><code>&lt;verb&gt;</code>: Command verb from API definition</li> <li><code>param=value</code>: Command parameters (key=value pairs)</li> <li><code>--plugin &lt;path&gt;</code>: Optional custom plugin</li> <li><code>--log-level &lt;level&gt;</code>: Logging level</li> </ul> <p>Examples:</p> <pre><code># Test identity query\ninstrument-server test configs/dmm1.yaml IDN\n\n# Test with parameters\ninstrument-server test configs/dac1.yaml SET_VOLTAGE channel=1 voltage=5.0\n\n# Test with custom plugin\ninstrument-server test configs/custom. yaml MEASURE --plugin ./my_plugin.so\n\n# Test with debug logging\ninstrument-server test configs/scope1.yaml TRIGGER --log-level debug\n</code></pre> <p>Output:</p> <pre><code>Testing instrument: DMM1\nExecuting command: IDN\n\nResult: \n  Success: YES\n  Response:  Keithley Instruments Inc., Model 2400, 1234567, v1.0\n</code></pre> <p>Notes:</p> <ul> <li>Creates temporary instrument instance for testing</li> <li>Instrument is automatically stopped after test</li> <li>Useful for verifying plugin functionality</li> <li>Does not require daemon (starts temporary instance)</li> </ul>"},{"location":"CLI_USAGE/#plugin-management","title":"Plugin Management","text":"<p>Discover and manage instrument driver plugins.</p>"},{"location":"CLI_USAGE/#list-available-plugins","title":"List Available Plugins","text":"<pre><code>instrument-server plugins\n</code></pre> <p>Example:</p> <pre><code>instrument-server plugins\n</code></pre> <p>Output:</p> <pre><code>Available plugins:\n\n  VISA -&gt; /usr/local/lib/instrument-plugins/visa_builtin.so\n  SimpleSerial -&gt; /usr/local/lib/instrument-plugins/simple_serial_plugin.so\n  MockTest -&gt; ./mock_plugin.so\n\nTotal:  3 plugin(s)\n</code></pre> <p>Notes:</p> <ul> <li>Searches standard directories:</li> <li><code>/usr/local/lib/instrument-plugins/</code></li> <li><code>/usr/lib/instrument-plugins/</code></li> <li><code>./plugins/</code></li> <li><code>.</code> (current directory)</li> </ul>"},{"location":"CLI_USAGE/#discover-plugins","title":"Discover Plugins","text":"<pre><code>instrument-server discover [path1] [path2] ...\n</code></pre> <p>Arguments:</p> <ul> <li><code>[paths]</code>: Optional directories to search (uses defaults if none provided)</li> </ul> <p>Example:</p> <pre><code># Discover in default locations\ninstrument-server discover\n\n# Discover in custom directories\ninstrument-server discover /opt/custom-plugins ./local-plugins\n</code></pre> <p>Output:</p> <pre><code>Discovering plugins in: \n  /opt/custom-plugins\n  ./local-plugins\n\nFound 2 plugin(s):\n\nProtocol:  CustomDAQ\n  Path: /opt/custom-plugins/custom_daq. so\n  Name: Custom DAQ Plugin\n  Version: 2.1.0\n  Description: High-speed data acquisition plugin\n\nProtocol: MySerial\n  Path: ./local-plugins/my_serial.so\n  Name: My Serial Driver\n  Version: 1.0.0\n  Description: Custom serial protocol implementation\n</code></pre>"},{"location":"CLI_USAGE/#configuration-validation","title":"Configuration Validation","text":"<p>Validate configuration files against JSON schemas before using them.</p>"},{"location":"CLI_USAGE/#validate-command","title":"Validate Command","text":"<pre><code># Validate instrument configuration\ninstrument-server validate config &lt;file&gt;\n\n# Validate API definition\ninstrument-server validate api &lt;file&gt;\n</code></pre> <p>Examples:</p> <pre><code># Validate instrument configuration\ninstrument-server validate config examples/instrument-configurations/agi_34401_config.yaml\n\n# Validate API definition\ninstrument-server validate api examples/instrument-apis/agi_34401a.yaml\n</code></pre> <p>Output (success):</p> <pre><code>\u2713 Configuration is valid\n</code></pre> <p>Output (error):</p> <pre><code>\u2717 Validation failed:\n  - Field 'name' must match pattern ^[A-Z][A-Z0-9_]*$\n  - Missing required field 'io_config'\n</code></pre> <p>Notes:</p> <ul> <li>Validates against JSON schemas in <code>schemas/</code> directory</li> <li>Checks required fields, data types, and constraints</li> <li>Use before starting instruments to catch configuration errors early</li> </ul>"},{"location":"CLI_USAGE/#logging","title":"Logging","text":"<p>All commands support logging configuration via <code>--log-level</code>.</p>"},{"location":"CLI_USAGE/#log-levels","title":"Log Levels","text":"Level Description Use Case <code>error</code> Errors only Production, minimal output <code>warn</code> Warnings and errors Production <code>info</code> Informational messages Normal operation (default) <code>debug</code> Detailed debugging Development, troubleshooting <code>trace</code> Very detailed trace Deep debugging"},{"location":"CLI_USAGE/#log-files","title":"Log Files","text":"<p>Main log: <code>instrument_server.log</code></p> <ul> <li>Contains server daemon and command logs</li> <li>Location: Current directory when command executed</li> </ul> <p>Worker logs: <code>worker_&lt;instrument_name&gt;.log</code></p> <ul> <li>One log per instrument worker process</li> <li>Contains plugin execution details</li> <li>Location: Current directory</li> </ul> <p>Example log locations:</p> <pre><code>./instrument_server.log\n./worker_DMM1.log\n./worker_DAC1.log\n./worker_Scope1.log\n</code></pre>"},{"location":"CLI_USAGE/#viewing-logs","title":"Viewing Logs","text":"<pre><code># View main log\ntail -f instrument_server.log\n\n# View specific worker log\ntail -f worker_DMM1.log\n\n# Search for errors\ngrep ERROR *.log\n\n# Search for specific instrument\ngrep \"DMM1\" instrument_server.log\n</code></pre>"},{"location":"CLI_USAGE/#complete-workflow-examples","title":"Complete Workflow Examples","text":""},{"location":"CLI_USAGE/#example-1-basic-measurement","title":"Example 1: Basic Measurement","text":"<pre><code># 1. Start daemon\ninstrument-server daemon start\n\n# 2. Start instruments\ninstrument-server start configs/dac1.yaml\ninstrument-server start configs/dmm1.yaml\n\n# 3.  Verify instruments are running\ninstrument-server list\n\n# 4. Run measurement\ninstrument-server measure scripts/iv_curve.lua\n\n# 5. Check instrument status\ninstrument-server status DMM1\n\n# 6. Stop instruments\ninstrument-server stop DAC1\ninstrument-server stop DMM1\n\n# 7. Stop daemon\ninstrument-server daemon stop\n</code></pre>"},{"location":"CLI_USAGE/#example-2-development-workflow","title":"Example 2: Development Workflow","text":"<pre><code># 1. Start daemon with debug logging\ninstrument-server daemon start --log-level debug\n\n# 2. Validate configuration before using\ninstrument-server validate config configs/test_instrument.yaml\ninstrument-server validate api apis/test_api.yaml\n\n# 3. Test instrument with custom plugin\ninstrument-server test configs/test_instrument.yaml IDN --plugin ./my_plugin. so\n\n# If test succeeds, start instrument\ninstrument-server start configs/test_instrument.yaml --plugin ./my_plugin.so\n\n# 4. Run test measurement with debug logging\ninstrument-server measure scripts/test_measurement.lua --log-level debug\n\n# 5. Check logs for issues\ntail -f instrument_server.log\ntail -f worker_TestInstrument.log\n\n# 6. Stop and restart instrument if needed\ninstrument-server stop TestInstrument\ninstrument-server start configs/test_instrument.yaml --plugin ./my_plugin.so\n\n# 7. Cleanup\ninstrument-server daemon stop\n</code></pre>"},{"location":"CLI_USAGE/#example-3-multi-instrument-setup","title":"Example 3: Multi-Instrument Setup","text":"<pre><code># 1. Start daemon\ninstrument-server daemon start\n\n# 2. Discover available plugins\ninstrument-server plugins\n\n# 3. Start multiple instruments\ninstrument-server start configs/dac1.yaml\ninstrument-server start configs/dac2.yaml\ninstrument-server start configs/dac3.yaml\ninstrument-server start configs/dmm1.yaml\ninstrument-server start configs/dmm2.yaml\ninstrument-server start configs/scope1.yaml\n\n# 4. Verify all running\ninstrument-server list\n\n# 5. Check individual status\nfor inst in DAC1 DAC2 DAC3 DMM1 DMM2 Scope1; do\n    echo \"=== $inst ===\"\n    instrument-server status $inst\ndone\n\n# 6. Run complex measurement with parallel execution\ninstrument-server measure scripts/stability_diagram.lua\n\n# 7. Selective shutdown\ninstrument-server stop Scope1\n\n# 8. Continue with remaining instruments\ninstrument-server measure scripts/final_measurement.lua\n\n# 9. Complete shutdown\ninstrument-server daemon stop\n</code></pre>"},{"location":"CLI_USAGE/#example-4-troubleshooting","title":"Example 4: Troubleshooting","text":"<pre><code># 1. Check daemon status\ninstrument-server daemon status\n\n# If not running, start it\nif [ $? -ne 0 ]; then\n    instrument-server daemon start\nfi\n\n# 2. Validate configuration files\ninstrument-server validate config configs/problematic_instrument.yaml\ninstrument-server validate api apis/problematic_api.yaml\n\n# 3. Try starting instrument with debug logging\ninstrument-server start configs/problematic_instrument.yaml --log-level debug\n\n# 4. Check logs immediately\ntail -20 instrument_server.log\n\n# 5. Test specific command\ninstrument-server test configs/problematic_instrument.yaml IDN\n\n# 6. If plugin issue, try with explicit plugin path\ninstrument-server start configs/problematic_instrument.yaml \\\n    --plugin /usr/local/lib/instrument-plugins/visa_builtin.so \\\n    --log-level debug\n\n# 7. Monitor worker log\ntail -f worker_ProblematicInstrument.log\n\n# 8. Check IPC issues (Linux)\nls -la /tmp/instrument-server-$USER/\n\n# 9. Clean up if needed\ninstrument-server daemon stop\nrm -rf /tmp/instrument-server-$USER/\n</code></pre>"},{"location":"CLI_USAGE/#exit-codes","title":"Exit Codes","text":"<p>All commands return exit codes for scripting:</p> Code Meaning <code>0</code> Success <code>1</code> General error <p>Example script:</p> <pre><code>#!/bin/bash\n\ninstrument-server daemon start\nif [ $? -ne 0 ]; then\n    echo \"Failed to start daemon\"\n    exit 1\nfi\n\ninstrument-server start configs/dmm1.yaml\nif [ $? -ne 0 ]; then\n    echo \"Failed to start DMM1\"\n    instrument-server daemon stop\n    exit 1\nfi\n\ninstrument-server measure scripts/measurement.lua\nresult=$? \n\ninstrument-server daemon stop\nexit $result\n</code></pre>"},{"location":"CLI_USAGE/#environment-variables","title":"Environment Variables","text":"<p>Currently no environment variables are used.  Configuration is via:</p> <ul> <li>Command-line arguments</li> <li>Configuration files (YAML)</li> <li>Runtime directory determined by platform</li> </ul>"},{"location":"CLI_USAGE/#see-also","title":"See Also","text":"<ul> <li>Main README - Getting started and overview</li> <li>Configuration Guide - Writing configuration files</li> <li>Architecture - System design and components</li> <li>Plugin Development - Writing instrument plugins</li> <li>Synchronization Protocol - Parallel execution details</li> </ul>"},{"location":"CONFIGURATION/","title":"Configuration Guide","text":"<p>Complete guide to configuring instruments and writing API definitions.</p>"},{"location":"CONFIGURATION/#overview","title":"Overview","text":"<p>The Instrument Script Server uses two types of configuration files:</p> <ol> <li>Instrument Configuration - Defines a specific instrument instance with connection details</li> <li>Instrument API Definition - Defines the command set and protocol for an instrument type</li> </ol> <p>Both use YAML format and are validated against JSON schemas.</p>"},{"location":"CONFIGURATION/#instrument-configuration","title":"Instrument Configuration","text":""},{"location":"CONFIGURATION/#purpose","title":"Purpose","text":"<p>An instrument configuration file describes how to connect to a specific instrument instance on your system. It references an API definition and provides the physical connection details.</p>"},{"location":"CONFIGURATION/#schema-reference","title":"Schema Reference","text":"<p>The configuration is validated against <code>schemas/instrument_configuration.schema.json</code>.</p>"},{"location":"CONFIGURATION/#required-fields","title":"Required Fields","text":"<pre><code>name:  INSTRUMENT_NAME          # Unique identifier (uppercase with underscores)\napi_ref: path/to/api.yaml     # Path to the API definition file\nconnection:                     # Connection details\n  type: VISA                   # Connection type:  VISA or Custom\n  address: \"...\"              # Connection address\nio_config:                    # Configuration for each IO port\n  port_name: \n    type: float\n    role: input|output|inout\n    unit: V\n    offset: 0\n    scale: 1\n</code></pre>"},{"location":"CONFIGURATION/#field-descriptions","title":"Field Descriptions","text":""},{"location":"CONFIGURATION/#name-required","title":"<code>name</code> (required)","text":"<p>Type: String (pattern: <code>^[A-Z][A-Z0-9_]*$</code>)</p> <p>Description: Unique identifier for this instrument instance. This is how you'll reference the instrument in measurement scripts.</p> <p>Examples:</p> <ul> <li><code>DMM1</code>, <code>DMM2</code> - Multiple instances of the same instrument type</li> <li><code>SCOPE_LEFT</code>, <code>SCOPE_RIGHT</code> - Descriptive names</li> <li><code>DAC_GATE1</code>, <code>DAC_BIAS</code> - Function-based names</li> </ul>"},{"location":"CONFIGURATION/#api_ref-required","title":"<code>api_ref</code> (required)","text":"<p>Type: String (file path or file:// URI)</p> <p>Description: Path or URI that points to the instrument API definition file (the API describes the commands, IO and protocol for the instrument type). The server supports several forms and resolves them according to the rules below.</p> <p>Supported forms</p> <ul> <li>Absolute file-system path</li> <li>Example: <code>/usr/local/share/instrument-apis/keithley_2400.yaml</code></li> <li>Relative path (recommended when your API file is co-located with the instrument configuration)</li> <li>Example: <code>../apis/agi_34401a.yaml</code></li> <li><code>file://</code> URI (supported; treated as a file-system path)</li> <li>Examples:<ul> <li><code>file:///usr/local/share/instrument-apis/dmm.yaml</code></li> <li><code>file://./apis/agi_34401a.yaml</code></li> </ul> </li> </ul> <p>Resolution rules</p> <ol> <li>If <code>api_ref</code> is a <code>file://</code> URI, the <code>file://</code> scheme is stripped and the remainder is treated as a file-system path (special handling exists for typical Windows <code>file:///C:/...</code> forms).</li> <li>If the resulting path is absolute, it is used as-is. The server requires that the file exists.</li> <li>If the resulting path is relative, the server attempts to resolve it in two places (in this order):    a. The directory containing the instrument configuration file (i.e., the parent directory of the configuration file you passed to <code>instrument-server start ...</code>). This is the preferred/primary location and lets you keep the API file next to its configuration.    b. If (a) does not exist, the server falls back to resolving the relative path against the server process current working directory (cwd). This preserves backward compatibility with existing workflows and test expectations that used repo-root/cwd-relative paths.</li> <li>If the file cannot be found in either location, instrument creation fails with a clear error indicating the preferred (config-relative) path that was checked, e.g.:</li> </ol> <pre><code>API definition file not found: /path/to/configs/../apis/myapi.yaml\n</code></pre> <ol> <li>If the file is found, the resolved path is normalized (canonicalized) before being used, so <code>../</code> and <code>./</code> fragments are collapsed and the server uses the canonical absolute path.</li> </ol> <p>Notes &amp; best practices</p> <ul> <li>For reproducibility, prefer placing the API definition in the same repo/directory tree as the instrument configuration and use a relative path (this makes configurations portable between machines).</li> <li>If you distribute API definitions as part of a system installation, use absolute paths (or file:// URIs) to the installed location.</li> <li>The <code>instrument-server validate api &lt;file&gt;</code> command is available to validate an API definition YAML independently; use this before starting instruments to catch schema errors early.</li> <li>Error messages from the server are intentionally informative; when a referenced API cannot be found the server will log the attempted config-relative path to aid debugging.</li> </ul> <p>Examples</p> <pre><code># co-located API (preferred)\nname: DMM1\napi_ref: ../apis/agi_34401a.yaml\nconnection:\n  type: VISA\n  address: \"TCPIP::192.168.0.100::INSTR\"\n</code></pre> <pre><code># absolute path\nname: DMM2\napi_ref: /usr/local/share/instrument-apis/keithley_2400.yaml\nconnection:\n  type: VISA\n</code></pre> <pre><code># file:// URI\nname: DMM3\napi_ref: file:///etc/instrument-apis/dmm.yaml\nconnection:\n  type: VISA\n</code></pre>"},{"location":"CONFIGURATION/#connection-required","title":"<code>connection</code> (required)","text":"<p>Type: Object</p> <p>Description:  Specifies how to physically connect to the instrument.</p>"},{"location":"CONFIGURATION/#connectiontype-required","title":"<code>connection.type</code> (required)","text":"<p>Type: String (enum: <code>VISA</code> | <code>Custom</code>)</p> <p>Description: The connection protocol type.</p> <ul> <li><code>VISA</code>: For instruments using VISA protocol (GPIB, USB, LAN, Serial via VISA)</li> <li><code>Custom</code>: For custom protocols implemented in plugins</li> </ul>"},{"location":"CONFIGURATION/#connectionaddress-optional","title":"<code>connection.address</code> (optional)","text":"<p>Type: String</p> <p>Description: The connection address.  Format depends on the connection type.</p> <p>VISA Address Examples:</p> <ul> <li>GPIB: <code>GPIB0::15::INSTR</code></li> <li>LAN/Ethernet: <code>TCPIP::192.168.0.100::INSTR</code></li> <li>USB:  <code>USB0::0x1234::0x5678::SN123:: INSTR</code></li> <li>Serial (via VISA): <code>ASRL1::INSTR</code></li> </ul> <p>Custom Address Examples:</p> <ul> <li><code>/dev/ttyUSB0</code> (serial port)</li> <li><code>COM3</code> (Windows serial port)</li> <li><code>192.168.1.10: 5025</code> (TCP socket)</li> </ul>"},{"location":"CONFIGURATION/#connectionbaudrate-optional","title":"<code>connection.baudrate</code> (optional)","text":"<p>Type: Integer</p> <p>Description: Baud rate for serial connections.</p> <p>Example: <code>9600</code>, <code>115200</code></p>"},{"location":"CONFIGURATION/#connectioncustom-optional","title":"<code>connection.custom</code> (optional)","text":"<p>Type: Object</p> <p>Description: Additional custom connection parameters as key-value pairs.</p> <p>Example:</p> <pre><code>connection:\n  type: Custom\n  custom:\n    device: \"/dev/ttyUSB0\"\n    baudrate: 115200\n    parity: \"none\"\n    stop_bits: 1\n</code></pre>"},{"location":"CONFIGURATION/#startup-optional","title":"<code>startup</code> (optional)","text":"<p>Type: Object</p> <p>Description: Configuration for instrument startup behavior.</p>"},{"location":"CONFIGURATION/#startupinit_commands-optional","title":"<code>startup.init_commands</code> (optional)","text":"<p>Type: Array of strings</p> <p>Description: List of commands to send to the instrument immediately after connection.</p> <p>Example:</p> <pre><code>startup:\n  init_commands:\n    - \"*RST\"                    # Reset instrument\n    - \"*CLS\"                    # Clear status\n    - \"SYST:REM\"               # Set to remote mode\n</code></pre>"},{"location":"CONFIGURATION/#startupdelay_ms-optional","title":"<code>startup.delay_ms</code> (optional)","text":"<p>Type: Integer</p> <p>Description: Delay in milliseconds to wait after connecting before sending commands.</p> <p>Example: <code>1000</code> (wait 1 second after connection)</p>"},{"location":"CONFIGURATION/#io_config-required","title":"<code>io_config</code> (required)","text":"<p>Type: Object</p> <p>Description: Configuration for each IO port defined in the API. Each IO port that has role <code>input</code>, <code>output</code>, or <code>inout</code> must be configured here.</p> <p>Each IO configuration must specify:</p>"},{"location":"CONFIGURATION/#type-required","title":"<code>type</code> (required)","text":"<p>Type: String (enum: <code>int</code> | <code>float</code> | <code>bool</code> | <code>string</code>)</p> <p>Description: Data type for this IO port. Must match the type defined in the API.</p>"},{"location":"CONFIGURATION/#role-required","title":"<code>role</code> (required)","text":"<p>Type: String (enum: <code>input</code> | <code>output</code> | <code>inout</code>)</p> <p>Description: Direction of data flow.  Must match the role defined in the API.</p> <ul> <li><code>input</code>: Data flows into the instrument (e.g., voltage to set)</li> <li><code>output</code>: Data flows out from the instrument (e.g., measured current)</li> <li><code>inout</code>:  Bidirectional (e.g., configurable GPIO)</li> </ul>"},{"location":"CONFIGURATION/#unit-optional","title":"<code>unit</code> (optional)","text":"<p>Type: String</p> <p>Description: Physical unit for this IO port (e.g., <code>V</code>, <code>A</code>, <code>Hz</code>).</p>"},{"location":"CONFIGURATION/#offset-optional","title":"<code>offset</code> (optional)","text":"<p>Type: Number</p> <p>Description: Offset value applied to the data: <code>actual_value = raw_value * scale + offset</code></p> <p>Default: <code>0</code></p>"},{"location":"CONFIGURATION/#scale-optional","title":"<code>scale</code> (optional)","text":"<p>Type: Number</p> <p>Description: Scale factor applied to the data: <code>actual_value = raw_value * scale + offset</code></p> <p>Default: <code>1</code></p>"},{"location":"CONFIGURATION/#complete-examples","title":"Complete Examples","text":""},{"location":"CONFIGURATION/#example-1-digital-multimeter-visa-over-lan","title":"Example 1: Digital Multimeter (VISA over LAN)","text":"<pre><code>name: DMM1\napi_ref:  examples/instrument-apis/agi_34401a.yaml\nconnection:\n  type: VISA\n  address: \"TCPIP::192.168.0.100::INSTR\"\n  timeout: 5000\nstartup:\n  init_commands: \n    - \"*RST\"\n    - \"*CLS\"\n  delay_ms: 500\nio_config:\n  voltage: \n    type: float\n    role: input\n    unit: V\n    offset: 0\n    scale: 1\n  measured_voltage:\n    type: float\n    role: output\n    unit: V\n    offset: 0\n    scale: 1\n</code></pre>"},{"location":"CONFIGURATION/#example-2-oscilloscope-with-multiple-channels","title":"Example 2: Oscilloscope with Multiple Channels","text":"<pre><code>name: SCOPE1\napi_ref: examples/instrument-apis/dso9254a_extended.yaml\nconnection:\n  type: VISA\n  address: \"USB0::0x0957::0x179B::MY12345678::INSTR\"\nio_config:\n  analog1_waveform:\n    type: float\n    role: output\n    unit: V\n  analog2_waveform: \n    type: float\n    role:  output\n    unit: V\n  analog3_waveform:\n    type: float\n    role: output\n    unit: V\n  analog4_waveform:\n    type: float\n    role: output\n    unit: V\n  timebase:\n    type: float\n    role: setting\n    unit: s\n</code></pre>"},{"location":"CONFIGURATION/#example-3-custom-serial-instrument","title":"Example 3: Custom Serial Instrument","text":"<pre><code>name: CUSTOM_DEVICE\napi_ref: apis/custom_serial_device.yaml\nconnection:\n  type: Custom\n  custom:\n    device: \"/dev/ttyUSB0\"\n    baudrate:  115200\nio_config:\n  setpoint:\n    type: float\n    role: input\n    unit: degC\n    offset: 0\n    scale: 1\n  temperature:\n    type: float\n    role: output\n    unit: degC\n    offset: 0\n    scale:  1\n</code></pre>"},{"location":"CONFIGURATION/#instrument-api-definition","title":"Instrument API Definition","text":""},{"location":"CONFIGURATION/#purpose_1","title":"Purpose","text":"<p>An API definition file describes what commands an instrument type supports and how to send those commands.  It's protocol-agnostic and reusable across multiple instances of the same instrument model.</p>"},{"location":"CONFIGURATION/#schema-reference_1","title":"Schema Reference","text":"<p>The API is validated against <code>schemas/instrument_api.schema.json</code>.</p>"},{"location":"CONFIGURATION/#required-fields_1","title":"Required Fields","text":"<pre><code>api_version: \"1.0.0\"           # API schema version\ninstrument:                      # Instrument metadata\n  vendor:  \"Vendor Name\"\n  model: \"Model Number\"\n  identifier: \"UNIQUE_ID\"\nprotocol:                       # Protocol type\n  type:  VISA\nio:                             # IO port definitions\n  - name: port_name\n    type: float\n    role: input|output|setting\n    unit: V\n    description: \"...\"\ncommands:                      # Command definitions\n  COMMAND_NAME:\n    template: \"SCPI: COMMAND {param}\"\n    description: \"...\"\n    parameters: [...]\n    outputs: [...]\n</code></pre>"},{"location":"CONFIGURATION/#field-descriptions_1","title":"Field Descriptions","text":""},{"location":"CONFIGURATION/#api_version-required","title":"<code>api_version</code> (required)","text":"<p>Type: String (pattern: <code>^[0-9]+\\.[0-9]+\\.[0-9]+$</code>)</p> <p>Description: Semantic version of the API schema format.</p> <p>Example: <code>1.0.0</code></p>"},{"location":"CONFIGURATION/#instrument-required","title":"<code>instrument</code> (required)","text":"<p>Type: Object</p> <p>Description: Metadata about the instrument.</p>"},{"location":"CONFIGURATION/#instrumentvendor-required","title":"<code>instrument.vendor</code> (required)","text":"<p>Type: String</p> <p>Description:  Manufacturer name.</p> <p>Examples:  <code>Keysight</code>, <code>Agilent</code>, <code>Rohde &amp; Schwarz</code>, <code>Tektronix</code></p>"},{"location":"CONFIGURATION/#instrumentmodel-required","title":"<code>instrument.model</code> (required)","text":"<p>Type: String</p> <p>Description: Model number or identifier.</p> <p>Examples: <code>DSO9254A</code>, <code>34401A</code>, <code>SMU2450</code></p>"},{"location":"CONFIGURATION/#instrumentidentifier-required","title":"<code>instrument.identifier</code> (required)","text":"<p>Type: String (pattern: <code>^[A-Z][A-Z0-9_]*$</code>)</p> <p>Description: Unique identifier for this API definition.</p> <p>Examples: <code>DMM1</code>, <code>SCOPE1</code>, <code>DAC_API</code></p>"},{"location":"CONFIGURATION/#instrumentdesc-optional","title":"<code>instrument.desc</code> (optional)","text":"<p>Type: String</p> <p>Description: Human-readable description of the instrument.</p> <p>Example: <code>High-Performance Oscilloscope with 4 analog channels</code></p>"},{"location":"CONFIGURATION/#protocol-required","title":"<code>protocol</code> (required)","text":"<p>Type: Object</p> <p>Description: Protocol configuration.</p>"},{"location":"CONFIGURATION/#protocoltype-required","title":"<code>protocol.type</code> (required)","text":"<p>Type: String (enum: <code>VISA</code> | <code>Custom</code>)</p> <p>Description: Communication protocol.</p> <ul> <li><code>VISA</code>: Standard VISA protocol (plugin automatically uses VISA commands)</li> <li><code>Custom</code>: Custom protocol (requires a plugin implementation)</li> </ul>"},{"location":"CONFIGURATION/#io-required","title":"<code>io</code> (required)","text":"<p>Type: Array of objects</p> <p>Description:  Defines all IO ports (inputs, outputs, settings, triggers, etc.) for the instrument.</p> <p>Each IO port object has:</p>"},{"location":"CONFIGURATION/#ioname-required","title":"<code>io[].name</code> (required)","text":"<p>Type: String (pattern: <code>^[a-z][a-z0-9_]*$</code>)</p> <p>Description: IO port name (lowercase with underscores).</p> <p>Examples: <code>voltage</code>, <code>current</code>, <code>frequency</code>, <code>trigger_level</code></p>"},{"location":"CONFIGURATION/#iotype-required","title":"<code>io[].type</code> (required)","text":"<p>Type: String (enum: <code>int</code> | <code>float</code> | <code>bool</code> | <code>string</code> | <code>array&lt;float&gt;</code> | <code>array&lt;int&gt;</code>)</p> <p>Description: Data type for this IO port.</p>"},{"location":"CONFIGURATION/#iorole-required","title":"<code>io[].role</code> (required)","text":"<p>Type: String (enum: <code>input</code> | <code>output</code> | <code>inout</code> | <code>setting</code> | <code>trigger-in</code> | <code>trigger-out</code> | <code>clock-in</code> | <code>clock-out</code>)</p> <p>Description: The role/direction of this IO port.</p> <ul> <li><code>input</code>: Values written to the instrument</li> <li><code>output</code>: Values read from the instrument</li> <li><code>inout</code>: Bidirectional</li> <li><code>setting</code>: Configuration parameter</li> <li><code>trigger-in</code>: Trigger input</li> <li><code>trigger-out</code>: Trigger output</li> <li><code>clock-in</code>: Clock input</li> <li><code>clock-out</code>: Clock output</li> </ul>"},{"location":"CONFIGURATION/#iounit-optional","title":"<code>io[].unit</code> (optional)","text":"<p>Type: String</p> <p>Description: Physical unit.</p> <p>Examples: <code>V</code>, <code>A</code>, <code>Hz</code>, <code>s</code>, <code>degC</code>, <code>Ohm</code></p>"},{"location":"CONFIGURATION/#iodescription-optional","title":"<code>io[].description</code> (optional)","text":"<p>Type: String</p> <p>Description: Human-readable description of the IO port.</p>"},{"location":"CONFIGURATION/#channel_groups-optional","title":"<code>channel_groups</code> (optional)","text":"<p>Type: Array of objects</p> <p>Description:  Defines groups of channels (e.g., oscilloscope channels 1-4).</p> <p>See the dso9254a. yaml. tmpl example for usage.</p>"},{"location":"CONFIGURATION/#commands-required","title":"<code>commands</code> (required)","text":"<p>Type: Object</p> <p>Description:  Defines all commands the instrument supports.  Each key is a command name, and each value is a command definition.</p>"},{"location":"CONFIGURATION/#command-name-format","title":"Command Name Format","text":"<p>Pattern: <code>^[A-Z][A-Z0-9_]*$</code></p> <p>Examples:  <code>SET_VOLTAGE</code>, <code>MEASURE_CURRENT</code>, <code>GET_STATUS</code></p>"},{"location":"CONFIGURATION/#command-object","title":"Command Object","text":"<p>Each command has:</p>"},{"location":"CONFIGURATION/#template-required","title":"<code>template</code> (required)","text":"<p>Type: String</p> <p>Description:  The actual command string sent to the instrument.  Parameters in curly braces <code>{param}</code> are substituted at runtime.</p> <p>VISA/SCPI Examples:</p> <ul> <li><code>*IDN?</code> (identity query)</li> <li><code>:SOUR:VOLT {voltage}</code> (set voltage)</li> <li><code>:MEAS:VOLT: DC?</code> (measure voltage)</li> <li><code>:CHAN{channel}:RANG {range}</code> (set channel range, using channel group)</li> </ul>"},{"location":"CONFIGURATION/#description-optional","title":"<code>description</code> (optional)","text":"<p>Type: String</p> <p>Description: Human-readable description of what the command does.</p>"},{"location":"CONFIGURATION/#parameters-optional","title":"<code>parameters</code> (optional)","text":"<p>Type: Array of objects</p> <p>Description:  Input parameters for the command.</p> <p>Each parameter object:</p> <pre><code>- name: voltage          # Parameter name\n  type: float           # Data type\n  description: \"...\"    # Description (optional)\n  unit: V              # Physical unit (optional)\n</code></pre> <p>Alternatively, you can reference an IO port:</p> <pre><code>- io:  voltage           # References the IO port named \"voltage\"\n</code></pre>"},{"location":"CONFIGURATION/#outputs-optional","title":"<code>outputs</code> (optional)","text":"<p>Type: Array of strings</p> <p>Description: List of IO port names that this command produces values for.</p> <p>Example:</p> <pre><code>outputs:  [measured_voltage]   # This command produces a value for the \"measured_voltage\" IO port\n</code></pre>"},{"location":"CONFIGURATION/#returns-optional","title":"<code>returns</code> (optional)","text":"<p>Type: String (enum: <code>void</code> | <code>int</code> | <code>float</code> | <code>bool</code> | <code>string</code> | <code>array&lt;float&gt;</code> | <code>array&lt;int&gt;</code>)</p> <p>Description: The return type of the command.  Use <code>void</code> for commands that don't return a value.</p>"},{"location":"CONFIGURATION/#query-optional","title":"<code>query</code> (optional)","text":"<p>Type: Boolean</p> <p>Description: If <code>true</code>, this command is a query (reads data from the instrument). If <code>false</code> or omitted, it's a write command.</p>"},{"location":"CONFIGURATION/#channel_group-optional","title":"<code>channel_group</code> (optional)","text":"<p>Type: String</p> <p>Description: If this command operates on a channel, specify the channel group name here.</p>"},{"location":"CONFIGURATION/#complete-examples_1","title":"Complete Examples","text":""},{"location":"CONFIGURATION/#example-1-simple-digital-multimeter-api","title":"Example 1: Simple Digital Multimeter API","text":"<pre><code>api_version: \"1.0.0\"\ninstrument:\n  vendor: \"Agilent\"\n  model: \"34401A\"\n  identifier: \"DMM_API\"\n  desc: \"6. 5 Digit Digital Multimeter\"\n\nprotocol:\n  type: \"VISA\"\n\nio:\n  - name: voltage\n    type: float\n    role: input\n    description: \"Voltage to set\"\n    unit: \"V\"\n\n  - name: measured_voltage\n    type: float\n    role:  output\n    description: \"Measured DC voltage\"\n    unit: \"V\"\n\n  - name: range\n    type: float\n    role: setting\n    description: \"Measurement range\"\n    unit: \"V\"\n\ncommands:\n  IDN:\n    template: \"*IDN?\"\n    description: \"Query instrument identification\"\n    parameters: []\n    outputs: []\n    returns: string\n    query: true\n\n  RESET:\n    template: \"*RST\"\n    description: \"Reset instrument to default state\"\n    parameters: []\n    outputs: []\n    returns:  void\n\n  SET_VOLTAGE:\n    template:  \":SOUR:VOLT {voltage}\"\n    description: \"Set output voltage\"\n    parameters:\n      - io: voltage\n    outputs: []\n    returns: void\n\n  MEASURE_VOLTAGE:\n    template: \": MEAS:VOLT:DC?\"\n    description: \"Measure DC voltage\"\n    parameters:  []\n    outputs: [measured_voltage]\n    returns: float\n    query: true\n\n  SET_RANGE:\n    template:  \":VOLT:RANG {range}\"\n    description: \"Set measurement range\"\n    parameters:\n      - io:  range\n    outputs: []\n    returns: void\n\n  GET_RANGE:\n    template: \": VOLT:RANG?\"\n    description: \"Query current measurement range\"\n    parameters: []\n    outputs: [range]\n    returns: float\n    query: true\n</code></pre>"},{"location":"CONFIGURATION/#example-2-oscilloscope-with-channel-groups","title":"Example 2: Oscilloscope with Channel Groups","text":"<pre><code>api_version: \"1.0.0\"\ninstrument:\n  vendor: \"Keysight\"\n  model: \"DSO9254A\"\n  identifier: \"SCOPE_API\"\n  desc: \"High-Performance Oscilloscope\"\n\nprotocol:\n  type: \"VISA\"\n\nchannel_groups:\n  - name:  analog\n    description: \"Analog input channels\"\n    channel_parameter: \n      name: channel\n      type: int\n      min: 1\n      max: 4\n      description: \"Oscilloscope channel number (1-4)\"\n    io_types:\n      - suffix: waveform\n        type: float\n        role: output\n        unit: \"V\"\n        description: \"Waveform data\"\n      - suffix: voltage_range\n        type: float\n        role: setting\n        unit: \"V\"\n        description: \"Voltage range in volts\"\n\nio:\n  - name: timebase\n    type: float\n    role: setting\n    description: \"Global timebase setting\"\n    unit: \"s\"\n\n  # The channel group automatically creates: \n  # analog1_waveform, analog2_waveform, analog3_waveform, analog4_waveform\n  # analog1_voltage_range, analog2_voltage_range, etc. \n\ncommands:\n  GET_WAVEFORM:\n    template: \":WAV:DATA?  {analog}\"\n    description: \"Retrieve waveform data from specified channel\"\n    parameters:  []\n    channel_group: analog\n    outputs: [waveform]\n    returns: array&lt;float&gt;\n    query: true\n\n  SET_VOLTAGE_RANGE: \n    template: \":CHAN{analog}:RANG {value}\"\n    description: \"Set voltage range for channel\"\n    parameters:\n      - name: value\n        type: float\n        description: \"Voltage range in volts\"\n        unit: \"V\"\n    channel_group: analog\n    outputs:  [voltage_range]\n    returns:  void\n\n  SET_TIMEBASE:\n    template: \":TIM:SCAL {timebase}\"\n    description: \"Set timebase (time per division)\"\n    parameters:\n      - io: timebase\n    outputs: []\n    returns: void\n</code></pre>"},{"location":"CONFIGURATION/#configuration-validation","title":"Configuration Validation","text":"<p>The server includes built-in validation tools to check your configuration files against the JSON schemas.</p>"},{"location":"CONFIGURATION/#validating-configurations","title":"Validating Configurations","text":"<pre><code># Validate an instrument configuration\ninstrument-server validate config path/to/config.yaml\n\n# Validate an API definition\ninstrument-server validate api path/to/api.yaml\n</code></pre>"},{"location":"CONFIGURATION/#common-validation-errors","title":"Common Validation Errors","text":""},{"location":"CONFIGURATION/#error-name-must-match-pattern-a-za-z0-9_","title":"Error: \"name must match pattern ^[A-Z][A-Z0-9_]*$\"","text":"<p>Problem:  Instrument name uses lowercase or special characters.</p> <p>Solution: Use uppercase letters, numbers, and underscores only.  Must start with a letter.</p> <p>Bad: <code>dmm1</code>, <code>DMM-1</code>, <code>1DMM</code> Good: <code>DMM1</code>, <code>DMM_PRIMARY</code>, <code>SCOPE_A</code></p>"},{"location":"CONFIGURATION/#error-unknown-connection-type","title":"Error: \"Unknown connection type\"","text":"<p>Problem: <code>connection.type</code> is not <code>VISA</code> or <code>Custom</code>.</p> <p>Solution: Use exactly <code>VISA</code> or <code>Custom</code> (case-sensitive).</p>"},{"location":"CONFIGURATION/#error-io_config-missing-required-port","title":"Error: \"io_config missing required port\"","text":"<p>Problem: An IO port with role <code>input</code>, <code>output</code>, or <code>inout</code> is defined in the API but not configured.</p> <p>Solution: Add the missing IO port to <code>io_config</code> in your configuration file.</p>"},{"location":"CONFIGURATION/#error-command-template-missing-parameter","title":"Error: \"Command template missing parameter\"","text":"<p>Problem: A parameter is referenced in <code>{braces}</code> in the template but not defined in <code>parameters</code>.</p> <p>Solution: Add the parameter to the <code>parameters</code> list.</p>"},{"location":"CONFIGURATION/#best-practices","title":"Best Practices","text":""},{"location":"CONFIGURATION/#configuration-files","title":"Configuration Files","text":"<ol> <li>Use descriptive names:  <code>DMM_GATE_VOLTAGE</code> is better than <code>DMM1</code></li> <li>Group related instruments: Use prefixes like <code>DAC_</code>, <code>SCOPE_</code>, etc.</li> <li>Document with comments:  YAML supports <code>#</code> comments</li> <li>Keep connection details separate: Consider environment variables for addresses</li> <li>Validate before use: Always run validation before starting instruments</li> </ol>"},{"location":"CONFIGURATION/#api-definitions","title":"API Definitions","text":"<ol> <li>Be explicit:  Provide descriptions for all commands and IO ports</li> <li>Use consistent naming: Follow SCPI conventions if applicable</li> <li>Define units: Always specify physical units for measurements</li> <li>Group related IOs: Use channel groups for multi-channel instruments</li> <li>Test incrementally: Start with basic commands (IDN, RESET) before adding complex ones</li> </ol>"},{"location":"CONFIGURATION/#example-directory-structure","title":"Example Directory Structure","text":"<pre><code>my-lab-setup/\n\u251c\u2500\u2500 configs/\n\u2502   \u251c\u2500\u2500 dmm1.yaml              # Primary DMM\n\u2502   \u251c\u2500\u2500 dmm2.yaml              # Secondary DMM\n\u2502   \u251c\u2500\u2500 scope_left.yaml        # Left oscilloscope\n\u2502   \u2514\u2500\u2500 scope_right.yaml       # Right oscilloscope\n\u251c\u2500\u2500 apis/\n\u2502   \u251c\u2500\u2500 agilent_34401a.yaml   # DMM API\n\u2502   \u2514\u2500\u2500 keysight_scope. yaml   # Oscilloscope API\n\u2514\u2500\u2500 scripts/\n    \u251c\u2500\u2500 iv_curve. lua\n    \u251c\u2500\u2500 stability_diagram.lua\n    \u2514\u2500\u2500 calibration.lua\n</code></pre>"},{"location":"CONFIGURATION/#see-also","title":"See Also","text":"<ul> <li>CLI Usage Guide - How to use the command-line interface</li> <li>Plugin Development Guide - Creating custom instrument drivers</li> <li>Architecture Documentation - System design and internals</li> <li>Example Configurations - Working configuration examples</li> <li>Example APIs - Working API definition examples</li> </ul>"},{"location":"IPC_PROTOCOL/","title":"IPC Protocol Specification","text":"<ul> <li>IPC Protocol Specification</li> <li>Overview</li> <li>Queue Architecture</li> <li>Message Structure</li> <li>Message Types<ul> <li>COMMAND (Server \u2192 Worker)</li> <li>RESPONSE (Worker \u2192 Server)</li> </ul> </li> <li>Protocol Flow<ul> <li>Normal Command Execution</li> <li>With Heartbeat</li> <li>Graceful Shutdown</li> <li>Worker Death</li> </ul> </li> <li>Message Ordering</li> <li>Timeout Handling<ul> <li>Command Timeout</li> <li>Queue Timeout</li> </ul> </li> <li>Error Handling<ul> <li>Invalid Message</li> <li>Queue Full</li> <li>Worker Crash</li> </ul> </li> <li>Performance Characteristics<ul> <li>Latency</li> <li>Throughput</li> <li>Memory</li> </ul> </li> <li>Platform Differences<ul> <li>Linux</li> <li>Windows</li> </ul> </li> <li>Security Considerations</li> <li>Debugging<ul> <li>Inspect Queues (Linux)</li> <li>Monitor Messages</li> <li>Simulate Messages</li> </ul> </li> <li>Future Enhancements</li> </ul>"},{"location":"IPC_PROTOCOL/#overview","title":"Overview","text":"<p>Instrument workers communicate with the main server via Boost. Interprocess message queues using a bidirectional protocol.</p>"},{"location":"IPC_PROTOCOL/#queue-architecture","title":"Queue Architecture","text":"<p>Each instrument has two queues:</p> <ul> <li>Request Queue (<code>instrument_&lt;name&gt;_req</code>): Server \u2192 Worker</li> <li>Response Queue (<code>instrument_&lt;name&gt;_resp</code>): Worker \u2192 Server</li> </ul> <p>Queues are created in POSIX shared memory (<code>/dev/mqueue/</code> on Linux, named objects on Windows).</p>"},{"location":"IPC_PROTOCOL/#message-structure","title":"Message Structure","text":"<pre><code>struct IPCMessage {\n    Type type;              // Message type (4 bytes)\n    uint64_t id;            // Message ID for matching (8 bytes)\n    uint32_t payload_size;  // Size of payload (4 bytes)\n    char payload[8192];     // JSON payload (8192 bytes)\n};\n\nenum class Type :  uint32_t {\n    COMMAND = 1,\n    RESPONSE = 2,\n    SHUTDOWN = 3,\n    HEARTBEAT = 4,\n    ERROR = 5\n};\n</code></pre> <p>Total message size: 8208 bytes (fixed)</p>"},{"location":"IPC_PROTOCOL/#message-types","title":"Message Types","text":"<p>Instructs worker to execute a command.</p> <p>Payload: JSON-serialized ==SerializedCommand==</p> <pre><code>{\n  \"id\": \"DMM1-1234567890\",\n  \"instrument_name\": \"DMM1\",\n  \"verb\": \"MEASURE_VOLTAGE\",\n  \"timeout_ms\": 5000,\n  \"priority\": 0,\n  \"expects_response\": true,\n  \"return_type\": \"float\",\n  \"params\": {\n    \"range\": 10.0,\n    \"samples\": 100\n  }\n}\n</code></pre> <p>Fields:</p> <ul> <li>==id==: Unique command identifier</li> <li>==instrument_name==: Target instrument</li> <li>==verb==: Command name from API definition</li> <li>==timeout_ms==: Execution timeout in milliseconds</li> <li>==expects_response==: Whether command returns data</li> <li> <p>==params==: Key-value parameter map</p> </li> <li> </li> </ul> <p>Returns result of command execution.</p> <p>Payload: JSON-serialized ==CommandResponse==</p> <pre><code>{\n  \"command_id\": \"DMM1-1234567890\",\n  \"instrument_name\": \"DMM1\",\n  \"success\": true,\n  \"error_code\": 0,\n  \"error_message\": \"\",\n  \"text_response\": \"3.14159\",\n  \"return_value\": 3.14159\n}\n</code></pre> <p>Fields:</p> <ul> <li>==command_id==: Matches original command ID</li> <li>==success==: ==true== if command succeeded</li> <li>==error_code==: Non-zero error code on failure</li> <li>==error_message==: Human-readable error</li> <li>==text_response==: Raw text response from instrument</li> <li> <p>==return_value==: Parsed return value (type depends on command)</p> </li> <li> <p>HEARTBEAT (Worker \u2192 Server)</p> </li> </ul> <p>Worker alive signal, sent periodically (default: every 1 second).</p> <p>Payload: Empty (size = 0)</p> <p>Server tracks last heartbeat timestamp. Missing heartbeats trigger worker restart.</p> <ol> <li>SHUTDOWN (Server \u2192 Worker)</li> </ol> <p>Graceful shutdown request.</p> <p>Payload: Empty (size = 0)</p> <p>Worker should:</p> <ul> <li>Complete current command (if any)</li> <li>Call ==plugin_shutdown()==</li> <li>Clean up resources</li> <li> <p>Exit process</p> </li> <li> <p>ERROR (Worker \u2192 Server)</p> </li> </ul> <p>Fatal error notification (worker about to crash).</p> <p>Payload: JSON with error details</p> <pre><code>{\n  \"error_code\": -1,\n  \"error_message\": \"Plugin crashed:  segmentation fault\",\n  \"fatal\":  true\n}\n</code></pre>"},{"location":"IPC_PROTOCOL/#command-server-worker","title":"COMMAND (Server \u2192 Worker)","text":""},{"location":"IPC_PROTOCOL/#response-worker-server","title":"RESPONSE (Worker \u2192 Server)","text":""},{"location":"IPC_PROTOCOL/#protocol-flow","title":"Protocol Flow","text":""},{"location":"IPC_PROTOCOL/#normal-command-execution","title":"Normal Command Execution","text":"<pre><code>Server                           Worker\n  \u2502                                \u2502\n  \u251c\u2500\u2500\u2500 COMMAND (id=42) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                                \u251c\u2500 Execute plugin\n  \u2502                                \u251c\u2500 Get result\n  \u2502&lt;\u2500\u2500\u2500 RESPONSE (id=42) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                \u2502\n</code></pre>"},{"location":"IPC_PROTOCOL/#with-heartbeat","title":"With Heartbeat","text":"<pre><code>Server                           Worker\n  \u2502                                \u2502\n  \u251c\u2500\u2500\u2500 COMMAND (id=42) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500\u2500 HEARTBEAT \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 (every 1s)\n  \u2502                                \u251c\u2500 Long operation...\n  \u2502&lt;\u2500\u2500\u2500 HEARTBEAT \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502&lt;\u2500\u2500\u2500 RESPONSE (id=42) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                \u2502\n</code></pre>"},{"location":"IPC_PROTOCOL/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>Server                           Worker\n  \u2502                                \u2502\n  \u251c\u2500\u2500\u2500 SHUTDOWN \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                                \u251c\u2500 Finish current command\n  \u2502                                \u251c\u2500 plugin_shutdown()\n  \u2502                                \u251c\u2500 Exit(0)\n  \u2502                                X\n  \u2502\n  \u2514\u2500 Wait for process exit\n</code></pre>"},{"location":"IPC_PROTOCOL/#worker-death","title":"Worker Death","text":"<pre><code>Server                           Worker\n  \u2502                                \u2502\n  \u251c\u2500\u2500\u2500 COMMAND (id=42) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500\u2500 HEARTBEAT \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                \u251c\u2500 CRASH!\n  \u2502                                X\n  \u2502\n  \u251c\u2500 Detect missing heartbeat\n  \u251c\u2500 Mark worker as dead\n  \u2514\u2500 Fail pending commands\n</code></pre>"},{"location":"IPC_PROTOCOL/#message-ordering","title":"Message Ordering","text":"<ul> <li>FIFO: Messages are delivered in send order</li> <li>No reordering: Responses match request order</li> <li>Single-threaded worker: Commands execute serially</li> </ul>"},{"location":"IPC_PROTOCOL/#timeout-handling","title":"Timeout Handling","text":""},{"location":"IPC_PROTOCOL/#command-timeout","title":"Command Timeout","text":"<p>If worker doesn't respond within ==timeout_ms==:</p> <ol> <li>Server-side future times out</li> <li>Promise is fulfilled with timeout error</li> <li>Worker continues execution (can't be canceled)</li> <li>Late response is discarded</li> </ol>"},{"location":"IPC_PROTOCOL/#queue-timeout","title":"Queue Timeout","text":"<p>Send/receive operations have separate timeouts:</p> <ul> <li>Send timeout: 1 second (prevents blocking on full queue)</li> <li>Receive timeout: Varies by context (heartbeat: 1s, command: per-command timeout)</li> </ul>"},{"location":"IPC_PROTOCOL/#error-handling","title":"Error Handling","text":""},{"location":"IPC_PROTOCOL/#invalid-message","title":"Invalid Message","text":"<p>Worker receives malformed JSON:</p> <pre><code>// Worker logs error and sends ERROR message\nIPCMessage error_msg;\nerror_msg.type = Type::ERROR;\nsnprintf(error_msg.payload, sizeof(error_msg.payload),\n         \"{\\\"error_message\\\": \\\"Invalid JSON in command\\\"}\");\nsend(error_msg);\n</code></pre>"},{"location":"IPC_PROTOCOL/#queue-full","title":"Queue Full","text":"<p>Server can't send because queue is full (100 messages buffered):</p> <ul> <li>Server logs warning</li> <li>Returns timeout error to caller</li> <li>May indicate worker is stuck/slow</li> </ul>"},{"location":"IPC_PROTOCOL/#worker-crash","title":"Worker Crash","text":"<p>Worker process dies unexpectedly:</p> <ul> <li>Heartbeat monitoring detects death (within 10s)</li> <li>All pending commands fail with \"Worker died\" error</li> <li>Server can optionally restart worker (future enhancement)</li> </ul>"},{"location":"IPC_PROTOCOL/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"IPC_PROTOCOL/#latency","title":"Latency","text":"<ul> <li>Typical round-trip: &lt; 1 ms (VISA command)</li> <li>IPC overhead: &lt; 100 \u00b5s</li> <li>JSON serialization: ~ 50 \u00b5s per message</li> </ul>"},{"location":"IPC_PROTOCOL/#throughput","title":"Throughput","text":"<ul> <li>Queue depth: 100 messages</li> <li>Message size: 8208 bytes</li> <li>Max throughput: ~10,000 commands/sec (if worker keeps up)</li> </ul>"},{"location":"IPC_PROTOCOL/#memory","title":"Memory","text":"<ul> <li>Per instrument: ~1.6 MB (2 queues \u00d7 100 msgs \u00d7 8208 bytes)</li> <li>Scalable: Shared memory, not copied per-process</li> </ul>"},{"location":"IPC_PROTOCOL/#platform-differences","title":"Platform Differences","text":""},{"location":"IPC_PROTOCOL/#linux","title":"Linux","text":"<ul> <li>Queues in /dev/mqueue/</li> <li>Cleanup: rm /dev/mqueue/instrument_*</li> <li>Max queue size: cat /proc/sys/fs/mqueue/msg_max</li> </ul>"},{"location":"IPC_PROTOCOL/#windows","title":"Windows","text":"<ul> <li>Named kernel objects</li> <li>Cleanup: Automatic on last process close</li> <li>No practical size limits</li> </ul>"},{"location":"IPC_PROTOCOL/#security-considerations","title":"Security Considerations","text":"<ul> <li>No authentication: Any process can open queues (future: use permissions)</li> <li>No encryption: Data in plaintext in shared memory</li> <li>Sandboxing: Workers should run with limited privileges</li> </ul>"},{"location":"IPC_PROTOCOL/#debugging","title":"Debugging","text":""},{"location":"IPC_PROTOCOL/#inspect-queues-linux","title":"Inspect Queues (Linux)","text":"<pre><code># List queues\nls -l /dev/mqueue/\n\n# Check queue attributes\ncat /dev/mqueue/instrument_DMM1_req\n</code></pre>"},{"location":"IPC_PROTOCOL/#monitor-messages","title":"Monitor Messages","text":"<pre><code># Log all IPC traffic\nexport INSTRUMENT_IPC_DEBUG=1\ninstrument-server --config ...\n</code></pre>"},{"location":"IPC_PROTOCOL/#simulate-messages","title":"Simulate Messages","text":"<pre><code># Send test message (requires custom tool)\nipc-send --queue instrument_DMM1_req --type COMMAND --payload '{\"id\":\"test\",... }'\n</code></pre>"},{"location":"IPC_PROTOCOL/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Zero-copy large data: Separate shared memory region for waveforms</li> <li>Message compression: Compress JSON payloads &gt; 1KB</li> <li>Priority queues: High-priority commands bypass queue</li> <li>Message batching: Send multiple commands in one IPC message</li> <li>Bidirectional streaming: For continuous acquisition</li> </ul>"},{"location":"PLUGIN_DEVELOPMENT/","title":"Plugin Development Guide","text":"<p>Complete guide to developing instrument driver plugins for the Instrument Server.</p>"},{"location":"PLUGIN_DEVELOPMENT/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Plugin Development Guide</li> <li>Table of Contents</li> <li>Overview<ul> <li>Why Plugins?</li> <li>Plugin Types</li> </ul> </li> <li>Built-in Plugins</li> <li>Plugin Interface<ul> <li>Required Functions</li> <li>Header File</li> </ul> </li> <li>Quick Start<ul> <li>Step 1: Install InstrumentServer</li> <li>Step 2: Create Your Plugin Project</li> <li>Step 3: Build and Install</li> <li>Step 4: Test Your Plugin</li> </ul> </li> <li>Development Workflow<ul> <li>Using add_instrument_plugin() Helper</li> <li>Without add_instrument_plugin() Helper</li> </ul> </li> <li>Building Plugins<ul> <li>Linux</li> <li>macOS</li> <li>Windows</li> <li>Cross-Platform CMake</li> </ul> </li> <li>Testing Plugins<ul> <li>1. Verify Plugin Loads</li> <li>2. Test Metadata</li> <li>3. Test Commands</li> <li>4. Integration Testing</li> <li>5. Unit Testing Plugin Directly</li> </ul> </li> <li>Example Plugins<ul> <li>Example 1: Simple Echo Plugin (No Dependencies)</li> <li>Example 2: Serial Port Plugin</li> <li>Example 3: VISA Plugin</li> </ul> </li> <li>Handling Large Data in Plugins<ul> <li>When to Use Data Buffers</li> <li>Creating Data Buffers in C Plugins</li> <li>Data Type Codes</li> <li>Buffer Lifecycle</li> <li>Linking to DataBufferManager</li> <li>Example: Oscilloscope Plugin</li> </ul> </li> <li>See Also</li> </ul>"},{"location":"PLUGIN_DEVELOPMENT/#overview","title":"Overview","text":"<p>Plugins are shared libraries (. so on Linux, .dll on Windows, .dylib on macOS) that implement the instrument driver interface. The server loads plugins dynamically at runtime.</p>"},{"location":"PLUGIN_DEVELOPMENT/#why-plugins","title":"Why Plugins?","text":"<ul> <li>Modularity: Add new instruments without recompiling server</li> <li>Isolation: Plugin crashes don't affect server</li> <li>Flexibility: Use any SDK (VISA, vendor SDKs, custom protocols)</li> <li>Distribution:  Distribute plugins independently</li> <li>Easy Development: Use <code>add_instrument_plugin()</code> CMake helper</li> </ul>"},{"location":"PLUGIN_DEVELOPMENT/#plugin-types","title":"Plugin Types","text":"Type Description Examples Protocol adapter Generic protocol handler VISA, Serial, TCP Vendor SDK Wraps vendor library NI-DAQmx, Keithley SDK Custom protocol Proprietary communication Custom serial, USB HID"},{"location":"PLUGIN_DEVELOPMENT/#built-in-plugins","title":"Built-in Plugins","text":"<p>The server includes the following built-in plugins that are automatically loaded:</p> Protocol Description Status VISA NI-VISA protocol for GPIB, USB, Ethernet, Serial \u2705 Built-in <p>These plugins are available without any configuration.  You only need to create custom plugins for:</p> <ul> <li>Proprietary vendor SDKs (NI-DAQmx, Keithley, etc.)</li> <li>Custom protocols not covered by VISA</li> <li>Special communication requirements</li> </ul>"},{"location":"PLUGIN_DEVELOPMENT/#plugin-interface","title":"Plugin Interface","text":""},{"location":"PLUGIN_DEVELOPMENT/#required-functions","title":"Required Functions","text":"<p>Every plugin must export these four C functions:</p> <pre><code>PluginMetadata plugin_get_metadata(void);\nint32_t plugin_initialize(const PluginConfig *config);\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp);\nvoid plugin_shutdown(void);\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#header-file","title":"Header File","text":"<p>Location: <code>&lt;instrument-server/plugin/PluginInterface.h&gt;</code></p> <p>After installing InstrumentServer, this header is available at:</p> <ul> <li>Linux/macOS: <code>/usr/local/include/instrument-server/plugin/PluginInterface.h</code></li> <li>Windows: <code>C:\\Program Files\\InstrumentServer\\include\\instrument-server\\plugin\\PluginInterface.h</code></li> </ul> <pre><code>#ifndef INSTRUMENT_PLUGIN_INTERFACE_H\n#define INSTRUMENT_PLUGIN_INTERFACE_H\n\n#include &lt;stdint.h&gt;\n\n#define INSTRUMENT_PLUGIN_API_VERSION 1\n#define PLUGIN_MAX_STRING_LEN 256\n#define PLUGIN_MAX_PAYLOAD 4096\n#define PLUGIN_MAX_PARAMS 32\n\n// Parameter types\ntypedef enum {\n    PARAM_TYPE_NONE = 0,\n    PARAM_TYPE_DOUBLE = 1,\n    PARAM_TYPE_INT64 = 2,\n    PARAM_TYPE_STRING = 3,\n    PARAM_TYPE_BOOL = 4,\n    PARAM_TYPE_UINT64 = 5\n} ParamType;\n\n// Parameter value union\ntypedef struct {\n    ParamType type;\n    union {\n        double d_val;\n        int64_t i64_val;\n        uint64_t u64_val;\n        char str_val[PLUGIN_MAX_STRING_LEN];\n        bool b_val;\n    } value;\n} PluginParamValue;\n\n// Named parameter\ntypedef struct {\n    char name[PLUGIN_MAX_STRING_LEN];\n    PluginParamValue value;\n} PluginParam;\n\n// Plugin metadata\ntypedef struct {\n    uint32_t api_version;\n    char name[PLUGIN_MAX_STRING_LEN];\n    char version[PLUGIN_MAX_STRING_LEN];\n    char protocol_type[PLUGIN_MAX_STRING_LEN];\n    char description[PLUGIN_MAX_STRING_LEN];\n} PluginMetadata;\n\n// Plugin configuration\ntypedef struct {\n    char instrument_name[PLUGIN_MAX_STRING_LEN];\n    char connection_json[PLUGIN_MAX_PAYLOAD];  // JSON string\n} PluginConfig;\n\n// Command from server\ntypedef struct {\n    char id[PLUGIN_MAX_STRING_LEN];\n    char instrument_name[PLUGIN_MAX_STRING_LEN];\n    char verb[PLUGIN_MAX_STRING_LEN];\n    bool expects_response;\n\n    uint32_t param_count;\n    PluginParam params[PLUGIN_MAX_PARAMS];\n} PluginCommand;\n\n// Response to server\ntypedef struct {\n    char command_id[PLUGIN_MAX_STRING_LEN];\n    char instrument_name[PLUGIN_MAX_STRING_LEN];\n\n    bool success;\n    int32_t error_code;\n    char error_message[PLUGIN_MAX_STRING_LEN];\n\n    char text_response[PLUGIN_MAX_PAYLOAD];\n    PluginParamValue return_value;\n} PluginResponse;\n\n// Plugin API functions (must be exported)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPluginMetadata plugin_get_metadata(void);\nint32_t plugin_initialize(const PluginConfig *config);\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp);\nvoid plugin_shutdown(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // INSTRUMENT_PLUGIN_INTERFACE_H\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#quick-start","title":"Quick Start","text":"<p>This is the recommended workflow for creating a custom plugin after installing InstrumentServer.</p>"},{"location":"PLUGIN_DEVELOPMENT/#step-1-install-instrumentserver","title":"Step 1: Install InstrumentServer","text":"<pre><code># Clone and build InstrumentServer\ngit clone https://github.com/falcon-autotuning/instrument-script-server.git\ncd instrument-script-server\nmkdir build &amp;&amp; cd build\ncmake .. \ncmake --build .\nsudo cmake --install .\n</code></pre> <p>This installs:</p> <ul> <li>Headers to <code>/usr/local/include/instrument-server/</code></li> <li>CMake config to <code>/usr/local/lib/cmake/InstrumentServer/</code></li> <li>Helper function <code>add_instrument_plugin()</code></li> </ul>"},{"location":"PLUGIN_DEVELOPMENT/#step-2-create-your-plugin-project","title":"Step 2: Create Your Plugin Project","text":"<pre><code>mkdir my_instrument_plugin\ncd my_instrument_plugin\n</code></pre> <p>Create <code>CMakeLists.txt</code>:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(MyInstrumentPlugin VERSION 1.0.0)\n\n# Find the installed InstrumentServer package\nfind_package(InstrumentServer REQUIRED)\n\n# Create your plugin using the helper function\nadd_instrument_plugin(my_instrument_plugin\n  SOURCES \n    my_plugin.c\n  LINK_LIBRARIES\n    # Add your instrument's SDK here\n    # my_instrument_sdk\n)\n\n# Install to standard location\ninstall(TARGETS my_instrument_plugin\n  LIBRARY DESTINATION lib/instrument-plugins\n)\n</code></pre> <p>Create <code>my_plugin.c</code>:</p> <pre><code>#include &lt;instrument-server/plugin/PluginInterface.h&gt;\n#include &lt;string.h&gt;\n\n// Your instrument SDK includes\n// #include &lt;my_instrument_sdk.h&gt;\n\nstatic void *g_device_handle = NULL;\n\nPluginMetadata plugin_get_metadata(void) {\n  PluginMetadata meta = {0};\n  meta.api_version = INSTRUMENT_PLUGIN_API_VERSION;\n  strncpy(meta.name, \"My Instrument Plugin\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta. version, \"1.0.0\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.protocol_type, \"MyInstrument\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.description, \"Driver for my custom instrument\", PLUGIN_MAX_STRING_LEN - 1);\n  return meta;\n}\n\nint32_t plugin_initialize(const PluginConfig *config) {\n  // Parse config-&gt;connection_json to get connection parameters\n  // Open connection to instrument\n  // g_device_handle = my_sdk_open(... );\n\n  if (g_device_handle == NULL) {\n    return -1;\n  }\n\n  return 0;\n}\n\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp) {\n  strncpy(resp-&gt;command_id, cmd-&gt;id, PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(resp-&gt;instrument_name, cmd-&gt;instrument_name, PLUGIN_MAX_STRING_LEN - 1);\n\n  if (strcmp(cmd-&gt;verb, \"IDN\") == 0) {\n    // Query instrument identity\n    // char idn[256];\n    // my_sdk_query(g_device_handle, \"*IDN?\", idn);\n\n    resp-&gt;success = true;\n    strncpy(resp-&gt;text_response, \"My Instrument v1.0\", PLUGIN_MAX_PAYLOAD - 1);\n    return 0;\n  }\n\n  if (strcmp(cmd-&gt;verb, \"MEASURE\") == 0) {\n    // Perform measurement\n    // double value = my_sdk_measure(g_device_handle);\n\n    resp-&gt;success = true;\n    resp-&gt;return_value.type = PARAM_TYPE_DOUBLE;\n    resp-&gt;return_value.value.d_val = 3.14159;  // Replace with actual measurement\n    return 0;\n  }\n\n  resp-&gt;success = false;\n  strncpy(resp-&gt;error_message, \"Unknown command\", PLUGIN_MAX_STRING_LEN - 1);\n  return -1;\n}\n\nvoid plugin_shutdown(void) {\n  if (g_device_handle) {\n    // my_sdk_close(g_device_handle);\n    g_device_handle = NULL;\n  }\n}\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#step-3-build-and-install","title":"Step 3: Build and Install","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake .. \ncmake --build .\nsudo cmake --install .\n</code></pre> <p>Your plugin is now installed to <code>/usr/local/lib/instrument-plugins/my_instrument_plugin.so</code></p>"},{"location":"PLUGIN_DEVELOPMENT/#step-4-test-your-plugin","title":"Step 4: Test Your Plugin","text":"<p>Create instrument configuration:</p> <pre><code># my_instrument. yaml\nname: MyInstrument1\napi_ref: my_api. yaml\nconnection: \n  type: MyInstrument  # Must match plugin's protocol_type\n  address: \"COM3\"      # Or whatever your instrument needs\n</code></pre> <pre><code># my_api.yaml\nprotocol: \n  type: MyInstrument\n\ncommands:\n  IDN:\n    description: \"Identity query\"\n    template: \"IDN\"\n    response_type: string\n\n  MEASURE:\n    description:  \"Perform measurement\"\n    template: \"MEASURE\"\n    response_type: double\n</code></pre> <p>Test the plugin:</p> <pre><code># Test with explicit plugin path\ninstrument-server test my_instrument.yaml IDN --plugin ./build/my_instrument_plugin.so\n\n# After installation, test without path\ninstrument-server test my_instrument.yaml IDN\n\n# If successful, start using it\ninstrument-server daemon start\ninstrument-server start my_instrument.yaml\ninstrument-server status MyInstrument1\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#development-workflow","title":"Development Workflow","text":""},{"location":"PLUGIN_DEVELOPMENT/#using-add_instrument_plugin-helper","title":"Using add_instrument_plugin() Helper","text":"<p>The <code>add_instrument_plugin()</code> CMake function (provided by InstrumentServer) automatically handles:</p> <p>\u2705 Creating MODULE library (for dynamic loading) \u2705 Removing <code>lib</code> prefix \u2705 Setting correct suffix (. so/. dll/. dylib) \u2705 Position-independent code \u2705 Symbol visibility \u2705 Include paths  </p> <p>Basic usage:</p> <pre><code>find_package(InstrumentServer REQUIRED)\n\nadd_instrument_plugin(my_plugin\n  SOURCES my_plugin. c\n)\n</code></pre> <p>With SDK dependencies:</p> <pre><code>add_instrument_plugin(my_plugin\n  SOURCES \n    my_plugin.c\n    helper. c\n  LINK_LIBRARIES\n    my_vendor_sdk\n  INCLUDE_DIRS\n    ${CMAKE_CURRENT_SOURCE_DIR}/include\n)\n</code></pre> <p>Multiple plugins:</p> <pre><code>add_instrument_plugin(plugin1 SOURCES plugin1.c)\nadd_instrument_plugin(plugin2 SOURCES plugin2.c)\nadd_instrument_plugin(plugin3 SOURCES plugin3.c)\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#without-add_instrument_plugin-helper","title":"Without add_instrument_plugin() Helper","text":"<p>If you prefer manual control or can't use the helper:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(MyPlugin)\n\nadd_library(my_plugin MODULE my_plugin.c)\n\nset_target_properties(my_plugin PROPERTIES\n  PREFIX \"\"                          # No 'lib' prefix\n  POSITION_INDEPENDENT_CODE ON\n  C_VISIBILITY_PRESET default        # Export symbols\n)\n\ntarget_include_directories(my_plugin PRIVATE\n  /usr/local/include  # Or wherever InstrumentServer is installed\n)\n\n# Link your SDK\ntarget_link_libraries(my_plugin PRIVATE my_instrument_sdk)\n\ninstall(TARGETS my_plugin LIBRARY DESTINATION lib/instrument-plugins)\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#building-plugins","title":"Building Plugins","text":""},{"location":"PLUGIN_DEVELOPMENT/#linux","title":"Linux","text":"<p>With CMake (recommended):</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake .. \ncmake --build .\nsudo cmake --install .\n</code></pre> <p>Manual compilation (for simple plugins):</p> <pre><code>gcc -shared -fPIC -o my_plugin.so my_plugin.c \\\n    -I/usr/local/include \\\n    -L/usr/local/lib -lmy_sdk\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#macos","title":"macOS","text":"<p>With CMake:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\ncmake --build .\nsudo cmake --install .\n</code></pre> <p>Manual compilation:</p> <pre><code>clang -shared -fPIC -o my_plugin.dylib my_plugin. c \\\n      -I/usr/local/include \\\n      -L/usr/local/lib -lmy_sdk\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#windows","title":"Windows","text":"<p>With CMake and MSVC:</p> <pre><code>mkdir build\ncd build\ncmake .. -G \"Visual Studio 16 2019\"\ncmake --build .  --config Release\ncmake --install . --config Release\n</code></pre> <p>With MinGW:</p> <pre><code>gcc -shared -o my_plugin. dll my_plugin.c ^\n    -I\"C:\\Program Files\\InstrumentServer\\include\" ^\n    -L\"C:\\Program Files\\MySDK\\lib\" -lmy_sdk\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#cross-platform-cmake","title":"Cross-Platform CMake","text":"<pre><code>cmake_minimum_required(VERSION 3.20)\nproject(MyPlugin)\n\nfind_package(InstrumentServer REQUIRED)\n\n# Works on all platforms\nadd_instrument_plugin(my_plugin\n  SOURCES my_plugin.c\n  LINK_LIBRARIES my_sdk\n)\n\n# Platform-specific options\nif(WIN32)\n  target_compile_definitions(my_plugin PRIVATE WINDOWS_SPECIFIC)\nelseif(APPLE)\n  target_compile_definitions(my_plugin PRIVATE MACOS_SPECIFIC)\nelse()\n  target_compile_definitions(my_plugin PRIVATE LINUX_SPECIFIC)\nendif()\n\ninstall(TARGETS my_plugin LIBRARY DESTINATION lib/instrument-plugins)\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#testing-plugins","title":"Testing Plugins","text":""},{"location":"PLUGIN_DEVELOPMENT/#1-verify-plugin-loads","title":"1. Verify Plugin Loads","text":"<pre><code># Check if plugin is discoverable\ninstrument-server plugins\n\n# Should list your plugin if installed to standard location\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#2-test-metadata","title":"2. Test Metadata","text":"<pre><code># Test with explicit path\ninstrument-server discover /path/to/my/plugins\n\n# Should show plugin details\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#3-test-commands","title":"3. Test Commands","text":"<pre><code># Create minimal config files (shown in Quick Start)\n# Then test individual commands\n\ninstrument-server test my_instrument.yaml IDN\ninstrument-server test my_instrument.yaml MEASURE\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#4-integration-testing","title":"4. Integration Testing","text":"<pre><code># Start daemon\ninstrument-server daemon start\n\n# Start instrument\ninstrument-server start my_instrument. yaml\n\n# Check status\ninstrument-server status MyInstrument1\n\n# Run measurement script\ninstrument-server measure dc test_measurement.lua\n\n# Cleanup\ninstrument-server stop MyInstrument1\ninstrument-server daemon stop\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#5-unit-testing-plugin-directly","title":"5. Unit Testing Plugin Directly","text":"<p>Create a test program:</p> <pre><code>// test_plugin.c\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n#include &lt;instrument-server/plugin/PluginInterface.h&gt;\n\nint main() {\n  // Load plugin\n  void *handle = dlopen(\"./my_plugin.so\", RTLD_NOW);\n  assert(handle != NULL);\n\n  // Get metadata\n  typedef PluginMetadata (*GetMetadataFunc)(void);\n  GetMetadataFunc get_metadata = dlsym(handle, \"plugin_get_metadata\");\n  assert(get_metadata != NULL);\n\n  PluginMetadata meta = get_metadata();\n  printf(\"Plugin:  %s v%s\\n\", meta.name, meta.version);\n  printf(\"Protocol: %s\\n\", meta.protocol_type);\n  assert(meta.api_version == INSTRUMENT_PLUGIN_API_VERSION);\n\n  // Test initialize\n  typedef int32_t (*InitFunc)(const PluginConfig*);\n  InitFunc init = dlsym(handle, \"plugin_initialize\");\n  assert(init != NULL);\n\n  PluginConfig config = {0};\n  strncpy(config.instrument_name, \"Test\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(config.connection_json, \"{\\\"address\\\":\\\"test\\\"}\", PLUGIN_MAX_PAYLOAD - 1);\n\n  int result = init(&amp;config);\n  printf(\"Initialize result: %d\\n\", result);\n  assert(result == 0);\n\n  // Test command\n  typedef int32_t (*ExecFunc)(const PluginCommand*, PluginResponse*);\n  ExecFunc exec = dlsym(handle, \"plugin_execute_command\");\n  assert(exec != NULL);\n\n  PluginCommand cmd = {0};\n  strncpy(cmd.id, \"test-1\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(cmd.instrument_name, \"Test\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(cmd.verb, \"IDN\", PLUGIN_MAX_STRING_LEN - 1);\n  cmd.expects_response = true;\n\n  PluginResponse resp = {0};\n  result = exec(&amp;cmd, &amp;resp);\n  printf(\"Command result: %d, success: %d\\n\", result, resp.success);\n  printf(\"Response: %s\\n\", resp.text_response);\n\n  // Cleanup\n  typedef void (*ShutdownFunc)(void);\n  ShutdownFunc shutdown = dlsym(handle, \"plugin_shutdown\");\n  if (shutdown) {\n    shutdown();\n  }\n\n  dlclose(handle);\n  printf(\"All tests passed!\\n\");\n  return 0;\n}\n</code></pre> <p>Compile and run:</p> <pre><code>gcc -o test_plugin test_plugin.c -ldl -I/usr/local/include\n./test_plugin\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#example-plugins","title":"Example Plugins","text":""},{"location":"PLUGIN_DEVELOPMENT/#example-1-simple-echo-plugin-no-dependencies","title":"Example 1: Simple Echo Plugin (No Dependencies)","text":"<pre><code>#include &lt;instrument-server/plugin/PluginInterface.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nstatic int g_initialized = 0;\n\nPluginMetadata plugin_get_metadata(void) {\n  PluginMetadata meta = {0};\n  meta.api_version = INSTRUMENT_PLUGIN_API_VERSION;\n  strncpy(meta.name, \"Echo Plugin\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.version, \"1.0.0\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.protocol_type, \"Echo\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.description, \"Simple echo plugin for testing\", PLUGIN_MAX_STRING_LEN - 1);\n  return meta;\n}\n\nint32_t plugin_initialize(const PluginConfig *config) {\n  fprintf(stderr, \"[Echo] Initializing for %s\\n\", config-&gt;instrument_name);\n  g_initialized = 1;\n  return 0;\n}\n\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp) {\n  strncpy(resp-&gt;command_id, cmd-&gt;id, PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(resp-&gt;instrument_name, cmd-&gt;instrument_name, PLUGIN_MAX_STRING_LEN - 1);\n\n  if (!g_initialized) {\n    resp-&gt;success = false;\n    strncpy(resp-&gt;error_message, \"Not initialized\", PLUGIN_MAX_STRING_LEN - 1);\n    return -1;\n  }\n\n  // Echo back the command verb\n  resp-&gt;success = true;\n  snprintf(resp-&gt;text_response, PLUGIN_MAX_PAYLOAD, \"Echo: %s\", cmd-&gt;verb);\n  return 0;\n}\n\nvoid plugin_shutdown(void) {\n  fprintf(stderr, \"[Echo] Shutting down\\n\");\n  g_initialized = 0;\n}\n</code></pre> <p>CMakeLists.txt:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(EchoPlugin)\n\nfind_package(InstrumentServer REQUIRED)\nadd_instrument_plugin(echo_plugin SOURCES echo_plugin.c)\ninstall(TARGETS echo_plugin LIBRARY DESTINATION lib/instrument-plugins)\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#example-2-serial-port-plugin","title":"Example 2: Serial Port Plugin","text":"<pre><code>#include &lt;instrument-server/plugin/PluginInterface.h&gt;\n#include &lt;string.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;termios.h&gt;\n\nstatic int g_fd = -1;\n\nPluginMetadata plugin_get_metadata(void) {\n  PluginMetadata meta = {0};\n  meta.api_version = INSTRUMENT_PLUGIN_API_VERSION;\n  strncpy(meta.name, \"Serial Port Plugin\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta. version, \"1.0.0\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.protocol_type, \"Serial\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.description, \"Serial port communication\", PLUGIN_MAX_STRING_LEN - 1);\n  return meta;\n}\n\nint32_t plugin_initialize(const PluginConfig *config) {\n  // Parse port from config-&gt;connection_json\n  const char *port = \"/dev/ttyUSB0\";  // TODO: Parse from JSON\n\n  g_fd = open(port, O_RDWR | O_NOCTTY);\n  if (g_fd &lt; 0) {\n    return -1;\n  }\n\n  // Configure serial port\n  struct termios options;\n  tcgetattr(g_fd, &amp;options);\n  cfsetispeed(&amp;options, B9600);\n  cfsetospeed(&amp;options, B9600);\n  options.c_cflag |= (CLOCAL | CREAD);\n  options.c_cflag &amp;= ~PARENB;\n  options.c_cflag &amp;= ~CSTOPB;\n  options.c_cflag &amp;= ~CSIZE;\n  options.c_cflag |= CS8;\n  tcsetattr(g_fd, TCSANOW, &amp;options);\n\n  return 0;\n}\n\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp) {\n  strncpy(resp-&gt;command_id, cmd-&gt;id, PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(resp-&gt;instrument_name, cmd-&gt;instrument_name, PLUGIN_MAX_STRING_LEN - 1);\n\n  if (g_fd &lt; 0) {\n    resp-&gt;success = false;\n    strncpy(resp-&gt;error_message, \"Port not open\", PLUGIN_MAX_STRING_LEN - 1);\n    return -1;\n  }\n\n  // Send command\n  char command[256];\n  snprintf(command, sizeof(command), \"%s\\n\", cmd-&gt;verb);\n  write(g_fd, command, strlen(command));\n\n  // Read response\n  char buffer[1024];\n  int n = read(g_fd, buffer, sizeof(buffer) - 1);\n\n  if (n &gt; 0) {\n    buffer[n] = '\\0';\n    resp-&gt;success = true;\n    strncpy(resp-&gt;text_response, buffer, PLUGIN_MAX_PAYLOAD - 1);\n    return 0;\n  }\n\n  resp-&gt;success = false;\n  strncpy(resp-&gt;error_message, \"Read failed\", PLUGIN_MAX_STRING_LEN - 1);\n  return -1;\n}\n\nvoid plugin_shutdown(void) {\n  if (g_fd &gt;= 0) {\n    close(g_fd);\n    g_fd = -1;\n  }\n}\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#example-3-visa-plugin","title":"Example 3: VISA Plugin","text":"<pre><code>#include &lt;instrument-server/plugin/PluginInterface.h&gt;\n#include &lt;visa. h&gt;\n#include &lt;string. h&gt;\n\nstatic ViSession g_rm = VI_NULL;\nstatic ViSession g_instr = VI_NULL;\n\nPluginMetadata plugin_get_metadata(void) {\n  PluginMetadata meta = {0};\n  meta.api_version = INSTRUMENT_PLUGIN_API_VERSION;\n  strncpy(meta.name, \"VISA Plugin\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.version, \"1.0.0\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.protocol_type, \"VISA\", PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(meta.description, \"VISA/SCPI instrument driver\", PLUGIN_MAX_STRING_LEN - 1);\n  return meta;\n}\n\nint32_t plugin_initialize(const PluginConfig *config) {\n  // Parse VISA address from config-&gt;connection_json\n  const char *address = \"TCPIP:: 192.168.1.1:: INSTR\";  // TODO: Parse from JSON\n\n  ViStatus status = viOpenDefaultRM(&amp;g_rm);\n  if (status &lt; VI_SUCCESS) {\n    return -1;\n  }\n\n  status = viOpen(g_rm, address, VI_NULL, VI_NULL, &amp;g_instr);\n  if (status &lt; VI_SUCCESS) {\n    viClose(g_rm);\n    return -2;\n  }\n\n  return 0;\n}\n\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp) {\n  strncpy(resp-&gt;command_id, cmd-&gt;id, PLUGIN_MAX_STRING_LEN - 1);\n  strncpy(resp-&gt;instrument_name, cmd-&gt;instrument_name, PLUGIN_MAX_STRING_LEN - 1);\n\n  if (g_instr == VI_NULL) {\n    resp-&gt;success = false;\n    strncpy(resp-&gt;error_message, \"VISA not initialized\", PLUGIN_MAX_STRING_LEN - 1);\n    return -1;\n  }\n\n  // Send SCPI command\n  viPrintf(g_instr, \"%s\\n\", cmd-&gt;verb);\n\n  // If expects response, read it\n  if (cmd-&gt;expects_response) {\n    char buffer[256];\n    ViUInt32 ret_count;\n    ViStatus status = viScanf(g_instr, \"%t\", &amp;ret_count, buffer);\n\n    if (status &gt;= VI_SUCCESS) {\n      resp-&gt;success = true;\n      strncpy(resp-&gt;text_response, buffer, PLUGIN_MAX_PAYLOAD - 1);\n      return 0;\n    }\n\n    resp-&gt;success = false;\n    resp-&gt;error_code = status;\n    return status;\n  }\n\n  resp-&gt;success = true;\n  return 0;\n}\n\nvoid plugin_shutdown(void) {\n  if (g_instr != VI_NULL) {\n    viClose(g_instr);\n    g_instr = VI_NULL;\n  }\n  if (g_rm != VI_NULL) {\n    viClose(g_rm);\n    g_rm = VI_NULL;\n  }\n}\n</code></pre> <p>CMakeLists.txt for VISA plugin:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(VISAPlugin)\n\nfind_package(InstrumentServer REQUIRED)\n\n# Find VISA library\nfind_library(VISA_LIBRARY NAMES visa visa64 PATHS /usr/local/vxipnp/linux64/lib)\n\nadd_instrument_plugin(visa_plugin\n  SOURCES visa_plugin.c\n  LINK_LIBRARIES ${VISA_LIBRARY}\n)\n\ninstall(TARGETS visa_plugin LIBRARY DESTINATION lib/instrument-plugins)\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#handling-large-data-in-plugins","title":"Handling Large Data in Plugins","text":""},{"location":"PLUGIN_DEVELOPMENT/#when-to-use-data-buffers","title":"When to Use Data Buffers","text":"<p>Use data buffers when your plugin returns:</p> <ul> <li>Oscilloscope waveforms (&gt;1000 points)</li> <li>Spectrum analyzer traces</li> <li>Camera images</li> <li>Large measurement arrays</li> <li>Any data &gt;1KB</li> </ul>"},{"location":"PLUGIN_DEVELOPMENT/#creating-data-buffers-in-c-plugins","title":"Creating Data Buffers in C Plugins","text":"<pre><code>#include &lt;instrument-server/ipc/DataBufferManager_C.h&gt;\n\nint32_t plugin_execute_command(const PluginCommand *cmd, PluginResponse *resp) {\n  // ... execute command and get data ...\n\n  // Example: Large waveform data\n  size_t num_points = 10000;\n  float *waveform = get_waveform_from_instrument();\n\n  // Create buffer\n  char buffer_id[PLUGIN_MAX_STRING_LEN];\n  int result = data_buffer_create(\n      cmd-&gt;instrument_name,\n      cmd-&gt;id,\n      0,  // 0 = FLOAT32, 1 = FLOAT64, 2 = INT32, etc.\n      num_points,\n      waveform,\n      buffer_id\n  );\n\n  if (result == 0) {\n    // Success - set response\n    resp-&gt;success = true;\n    resp-&gt;has_large_data = true;\n    strncpy(resp-&gt;data_buffer_id, buffer_id, PLUGIN_MAX_STRING_LEN - 1);\n    resp-&gt;data_element_count = num_points;\n    resp-&gt;data_type = 0;  // FLOAT32\n\n    snprintf(resp-&gt;text_response, PLUGIN_MAX_PAYLOAD,\n             \"Waveform data in buffer %s\", buffer_id);\n  } else {\n    resp-&gt;success = false;\n    strncpy(resp-&gt;error_message, \"Failed to create buffer\",\n            PLUGIN_MAX_STRING_LEN - 1);\n  }\n\n  free(waveform);\n  return result;\n}\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#data-type-codes","title":"Data Type Codes","text":"<pre><code>// Data type enum values for data_buffer_create()\n#define DATA_TYPE_FLOAT32  0\n#define DATA_TYPE_FLOAT64  1\n#define DATA_TYPE_INT32    2\n#define DATA_TYPE_INT64    3\n#define DATA_TYPE_UINT32   4\n#define DATA_TYPE_UINT64   5\n#define DATA_TYPE_UINT8    6\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#buffer-lifecycle","title":"Buffer Lifecycle","text":"<ol> <li>Plugin creates buffer - Calls <code>data_buffer_create()</code></li> <li>Server receives buffer ID - In <code>PluginResponse</code></li> <li>Lua accesses buffer - Via <code>get_buffer()</code></li> <li>User exports data - Calls <code>buffer:export_csv()</code> or <code>buffer:export_binary()</code></li> <li>User releases buffer - Calls <code>buffer:release()</code></li> <li>Auto cleanup - Buffer freed when ref count reaches 0</li> </ol>"},{"location":"PLUGIN_DEVELOPMENT/#linking-to-databuffermanager","title":"Linking to DataBufferManager","text":"<p>In your plugin's <code>CMakeLists.txt</code>:</p> <pre><code>target_link_libraries(your_plugin\n  PRIVATE\n    InstrumentServerCore  # Provides DataBufferManager C API\n)\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#example-oscilloscope-plugin","title":"Example: Oscilloscope Plugin","text":"<pre><code>int32_t get_waveform(const PluginCommand *cmd, PluginResponse *resp) {\n  // Query number of points\n  uint32_t num_points;\n  visa_query(g_session, \"WAV: POIN?\", &amp;num_points);\n\n  // Allocate temporary buffer\n  float *waveform = malloc(num_points * sizeof(float));\n\n  // Read waveform data from instrument\n  visa_read_binary(g_session, waveform, num_points);\n\n  // Create shared buffer\n  char buffer_id[PLUGIN_MAX_STRING_LEN];\n  if (data_buffer_create(cmd-&gt;instrument_name, cmd-&gt;id,\n                        DATA_TYPE_FLOAT32, num_points,\n                        waveform, buffer_id) == 0) {\n    resp-&gt;success = true;\n    resp-&gt;has_large_data = true;\n    strncpy(resp-&gt;data_buffer_id, buffer_id, PLUGIN_MAX_STRING_LEN - 1);\n    resp-&gt;data_element_count = num_points;\n    resp-&gt;data_type = DATA_TYPE_FLOAT32;\n  }\n\n  free(waveform);\n  return 0;\n}\n</code></pre>"},{"location":"PLUGIN_DEVELOPMENT/#see-also","title":"See Also","text":"<ul> <li>Architecture - System design</li> <li>CLI Usage - Testing plugins</li> <li>Main README - Getting started and installation</li> </ul>"},{"location":"SYNCHRONIZATION/","title":"Instrument Synchronization Protocol","text":"<p>Detailed documentation of the parallel execution and synchronization system.</p>"},{"location":"SYNCHRONIZATION/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Instrument Synchronization Protocol</li> <li>Table of Contents</li> <li>Overview<ul> <li>Key Features</li> </ul> </li> <li>Motivation<ul> <li>Problem:  Timing Skew Without Synchronization</li> <li>Solution: Synchronized Parallel Execution</li> </ul> </li> <li>Protocol Design<ul> <li>Sync Token System</li> <li>Message Types</li> <li>Protocol Flow</li> </ul> </li> <li>Implementation<ul> <li>RuntimeContext (Server Side)</li> <li>Parallel Block Detection</li> <li>Command Buffering</li> <li>Parallel Execution</li> <li>SyncCoordinator (Server Side)</li> <li>Barrier Registration</li> <li>ACK Handling</li> <li>Worker Process (Worker Side)</li> <li>Worker State</li> <li>Sending SYNC_ACK</li> <li>InstrumentWorkerProxy (Server Side)</li> <li>Handling SYNC_ACK</li> <li>Broadcasting SYNC_CONTINUE</li> </ul> </li> <li>Usage in Lua Scripts<ul> <li>Basic Parallel Block</li> <li>Parallel Read and Write</li> <li>Nested Loops with Sync</li> <li>Conditional Parallel Execution</li> </ul> </li> <li>Performance<ul> <li>Overhead Measurements</li> <li>Scaling</li> <li>Throughput</li> </ul> </li> <li>Debugging<ul> <li>Enable Sync Logging</li> <li>Log Patterns</li> <li>Worker Logs</li> <li>Timing Analysis</li> </ul> </li> <li>Troubleshooting<ul> <li>Problem: Parallel block never completes</li> <li>Problem: Commands execute sequentially despite parallel()</li> <li>Problem: SYNC_ACK timeout</li> <li>Problem: Incorrect timing despite sync</li> </ul> </li> <li>Advanced Topics<ul> <li>Multiple Parallel Blocks</li> <li>Partial Instrument Participation</li> <li>Error Handling in Parallel Blocks</li> </ul> </li> <li>See Also</li> </ul>"},{"location":"SYNCHRONIZATION/#overview","title":"Overview","text":"<p>The synchronization protocol enables multiple instruments to execute commands in lockstep during parallel execution blocks. This ensures precise timing coordination for experiments requiring simultaneous actions.</p>"},{"location":"SYNCHRONIZATION/#key-features","title":"Key Features","text":"<ul> <li>Barrier synchronization:  All instruments wait at sync points</li> <li>No timing skew: Commands complete before any instrument advances</li> <li>Scalable: Works with any number of instruments</li> <li>Transparent: Automatic in <code>parallel()</code> blocks</li> </ul>"},{"location":"SYNCHRONIZATION/#motivation","title":"Motivation","text":""},{"location":"SYNCHRONIZATION/#problem-timing-skew-without-synchronization","title":"Problem:  Timing Skew Without Synchronization","text":"<p>Consider setting voltages on three DACs:</p> <pre><code>-- WITHOUT synchronization (sequential)\ncontext:call(\"DAC1.SetVoltage\", 1.0)  -- t=0ms\ncontext:call(\"DAC2.SetVoltage\", 2.0)  -- t=50ms\ncontext:call(\"DAC3.SetVoltage\", 3.0)  -- t=100ms\n-- Time skew: 100ms between first and last\n</code></pre> <p>Problem: DAC1 settles 100ms before DAC3, causing:</p> <ul> <li>Transient measurement artifacts</li> <li>Invalid intermediate states</li> <li>Reproducibility issues</li> </ul>"},{"location":"SYNCHRONIZATION/#solution-synchronized-parallel-execution","title":"Solution: Synchronized Parallel Execution","text":"<pre><code>-- WITH synchronization (parallel)\ncontext:parallel(function()\n    context:call(\"DAC1.SetVoltage\", 1.0)\n    context:call(\"DAC2.SetVoltage\", 2.0)\n    context:call(\"DAC3.SetVoltage\", 3.0)\nend)\n-- All DACs set within ~1ms of each other\n</code></pre> <p>Benefit: All voltages set simultaneously, eliminating timing skew.</p>"},{"location":"SYNCHRONIZATION/#protocol-design","title":"Protocol Design","text":""},{"location":"SYNCHRONIZATION/#sync-token-system","title":"Sync Token System","text":"<p>Each parallel block is assigned a unique sync token (uint64_t). All commands in that block share the same token.</p> <pre><code>parallel block \u2192 sync_token=42\n\u251c\u2500\u2500 DAC1.SetVoltage(1.0)  [token=42]\n\u251c\u2500\u2500 DAC2.SetVoltage(2.0)  [token=42]\n\u2514\u2500\u2500 DAC3.SetVoltage(3.0)  [token=42]\n</code></pre>"},{"location":"SYNCHRONIZATION/#message-types","title":"Message Types","text":"<pre><code>enum class Type : uint32_t {\n    COMMAND = 1,        // Server \u2192 Worker: Execute command\n    RESPONSE = 2,       // Worker \u2192 Server: Command result\n    HEARTBEAT = 3,      // Worker \u2192 Server: Keep-alive\n    SHUTDOWN = 4,       // Server \u2192 Worker:  Terminate\n    SYNC_ACK = 5,       // Worker \u2192 Server: Sync command complete\n    SYNC_CONTINUE = 6   // Server \u2192 Worker:  All synced, proceed\n};\n</code></pre>"},{"location":"SYNCHRONIZATION/#protocol-flow","title":"Protocol Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. RuntimeContext:  Detect parallel() block             \u2502\n\u2502    - Set in_parallel_block_ = true                      \u2502\n\u2502    - Clear parallel_buffer_                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. RuntimeContext: Execute Lua block                    \u2502\n\u2502    - Each call() buffers command                        \u2502\n\u2502    - Commands NOT executed yet                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. RuntimeContext: Tag and dispatch                     \u2502\n\u2502    - Assign sync_token to all commands                  \u2502\n\u2502    - Register barrier with SyncCoordinator              \u2502\n\u2502    - Dispatch commands to InstrumentWorkerProxies       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193 IPC\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. Workers: Execute commands                            \u2502\n\u2502    - Receive COMMAND with sync_token                    \u2502\n\u2502    - Execute via plugin                                 \u2502\n\u2502    - Send RESPONSE                                      \u2502\n\u2502    - Send SYNC_ACK                                      \u2502\n\u2502    - BLOCK (wait for SYNC_CONTINUE)                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. SyncCoordinator: Collect ACKs                        \u2502\n\u2502    - Track ACKs from each instrument                    \u2502\n\u2502    - Wait until ALL instruments have ACKed              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6. Server:  Broadcast SYNC_CONTINUE                     \u2502\n\u2502    - Send SYNC_CONTINUE to all participants             \u2502\n\u2502    - Workers unblock                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 7. RuntimeContext: parallel() returns                   \u2502\n\u2502    - All instruments past sync point                    \u2502\n\u2502    - Lua script continues                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"SYNCHRONIZATION/#implementation","title":"Implementation","text":""},{"location":"SYNCHRONIZATION/#runtimecontext-server-side","title":"RuntimeContext (Server Side)","text":"<p>File: <code>src/server/RuntimeContext.cpp</code></p>"},{"location":"SYNCHRONIZATION/#parallel-block-detection","title":"Parallel Block Detection","text":"<pre><code>void RuntimeContextBase::parallel(sol::function block) {\n    LOG_DEBUG(\"LUA_CONTEXT\", \"PARALLEL\", \"Starting parallel block\");\n\n    in_parallel_block_ = true;\n    parallel_buffer_.clear();\n\n    // Execute Lua block - calls are buffered\n    try {\n        block();\n    } catch (const std::exception &amp;e) {\n        in_parallel_block_ = false;\n        parallel_buffer_.clear();\n        throw;\n    }\n\n    in_parallel_block_ = false;\n\n    // Execute buffered commands with sync\n    execute_parallel_buffer();\n\n    parallel_buffer_.clear();\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#command-buffering","title":"Command Buffering","text":"<pre><code>sol::object RuntimeContextBase::call(const std::string &amp;func_name,\n                                     sol::variadic_args args,\n                                     sol::this_state s) {\n    // ... parse func_name and args ...\n\n    if (in_parallel_block_) {\n        // Buffer command instead of executing\n        SerializedCommand cmd;\n        cmd.id = fmt::format(\"{}-buffered-{}\", instrument_id, parallel_buffer_.size());\n        cmd.instrument_name = instrument_id;\n        cmd.verb = verb;\n        cmd.params = params;\n\n        parallel_buffer_.push_back(std::move(cmd));\n        return sol::nil;  // Don't execute yet\n    }\n\n    // Normal execution for non-parallel calls\n    return send_command_immediate(instrument_id, verb, params);\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#parallel-execution","title":"Parallel Execution","text":"<pre><code>void RuntimeContextBase::execute_parallel_buffer() {\n    if (parallel_buffer_.empty()) {\n        return;\n    }\n\n    // Assign sync token\n    uint64_t sync_token = next_sync_token_++;\n\n    // Collect unique instruments\n    std::vector&lt;std::string&gt; instruments;\n    std::set&lt;std::string&gt; unique_instruments;\n    for (const auto &amp;cmd : parallel_buffer_) {\n        if (unique_instruments.insert(cmd.instrument_name).second) {\n            instruments.push_back(cmd.instrument_name);\n        }\n    }\n\n    // Register barrier\n    sync_coordinator_.register_barrier(sync_token, instruments);\n\n    // Tag and dispatch commands\n    std::vector&lt;std::future&lt;CommandResponse&gt;&gt; futures;\n    for (auto &amp;cmd : parallel_buffer_) {\n        cmd.sync_token = sync_token;  // Tag with sync token\n\n        auto worker = registry_.get_instrument(cmd.instrument_name);\n        if (! worker) {\n            LOG_ERROR(\"LUA_CONTEXT\", \"PARALLEL\", \"Instrument not found: {}\",\n                      cmd.instrument_name);\n            continue;\n        }\n\n        futures.push_back(worker-&gt;execute(std::move(cmd)));\n    }\n\n    // Wait for all commands to complete\n    for (auto &amp;future : futures) {\n        try {\n            auto resp = future.get();\n            if (!resp.success) {\n                LOG_ERROR(\"LUA_CONTEXT\", \"PARALLEL\", \"Command failed: {}\",\n                          resp. error_message);\n            }\n        } catch (const std::exception &amp;e) {\n            LOG_ERROR(\"LUA_CONTEXT\", \"PARALLEL\", \"Future exception: {}\", e.what());\n        }\n    }\n\n    LOG_INFO(\"LUA_CONTEXT\", \"PARALLEL\", \"Parallel block complete (token={})\", sync_token);\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#synccoordinator-server-side","title":"SyncCoordinator (Server Side)","text":"<p>File: <code>src/server/SyncCoordinator.cpp</code></p>"},{"location":"SYNCHRONIZATION/#barrier-registration","title":"Barrier Registration","text":"<pre><code>void SyncCoordinator::register_barrier(uint64_t sync_token,\n                                       const std::vector&lt;std::string&gt; &amp;instruments) {\n    std::lock_guard lock(mutex_);\n\n    SyncBarrier barrier;\n    barrier.expected_instruments = std::set&lt;std::string&gt;(instruments.begin(), \n                                                          instruments.end());\n    barrier.created_at = std::chrono:: steady_clock::now();\n\n    barriers_[sync_token] = std::move(barrier);\n\n    LOG_DEBUG(\"SYNC\", \"REGISTER\", \"Registered barrier token={} with {} instruments\",\n              sync_token, instruments.size());\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#ack-handling","title":"ACK Handling","text":"<pre><code>bool SyncCoordinator::handle_ack(uint64_t sync_token,\n                                 const std::string &amp;instrument_name) {\n    std::lock_guard lock(mutex_);\n\n    auto it = barriers_.find(sync_token);\n    if (it == barriers_.end()) {\n        LOG_WARN(\"SYNC\", \"ACK\", \"Unknown sync token: {}\", sync_token);\n        return false;\n    }\n\n    auto &amp;barrier = it-&gt;second;\n\n    // Check if this instrument is expected\n    if (barrier.expected_instruments.find(instrument_name) ==\n        barrier.expected_instruments.end()) {\n        LOG_WARN(\"SYNC\", \"ACK\", \"Unexpected ACK from {} for token {}\",\n                 instrument_name, sync_token);\n        return false;\n    }\n\n    // Record ACK\n    barrier.acked_instruments.insert(instrument_name);\n\n    LOG_DEBUG(\"SYNC\", \"ACK\", \"Instrument {} ACKed token {} ({}/{})\",\n              instrument_name, sync_token, \n              barrier.acked_instruments.size(),\n              barrier.expected_instruments. size());\n\n    // Check if all ACKed\n    bool complete = (barrier.acked_instruments == barrier.expected_instruments);\n\n    if (complete) {\n        LOG_INFO(\"SYNC\", \"COMPLETE\", \"Barrier {} complete, all {} instruments ACKed\",\n                 sync_token, barrier.expected_instruments.size());\n    }\n\n    return complete;\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#worker-process-worker-side","title":"Worker Process (Worker Side)","text":"<p>File: <code>src/workers/generic_worker_main.cpp</code></p>"},{"location":"SYNCHRONIZATION/#worker-state","title":"Worker State","text":"<pre><code>// Worker maintains sync state\nstd::optional&lt;uint64_t&gt; waiting_sync_token;\n\nwhile (running) {\n    // If blocked on sync, only process SYNC_CONTINUE\n    if (waiting_sync_token) {\n        auto msg = ipc_queue-&gt;receive(std::chrono::milliseconds(100));\n\n        if (! msg) continue;\n\n        if (msg-&gt;type == ipc::IPCMessage::Type::SYNC_CONTINUE &amp;&amp;\n            msg-&gt;sync_token == *waiting_sync_token) {\n            LOG_DEBUG(instrument_name, \"WORKER\", \n                     \"Received SYNC_CONTINUE for token={}, proceeding\",\n                     msg-&gt;sync_token);\n            waiting_sync_token. reset();  // Unblock\n        }\n        continue;\n    }\n\n    // Normal command processing\n    auto msg = ipc_queue-&gt;receive(std::chrono::milliseconds(100));\n    if (!msg || msg-&gt;type != ipc::IPCMessage::Type::COMMAND) {\n        continue;\n    }\n\n    // Execute command\n    SerializedCommand cmd = deserialize_command(msg-&gt;payload);\n    PluginResponse plugin_resp = execute_via_plugin(cmd);\n    CommandResponse resp = convert_response(plugin_resp);\n\n    // Send response\n    send_response(resp);\n\n    // If sync command, send ACK and block\n    if (cmd.sync_token) {\n        LOG_DEBUG(instrument_name, \"WORKER\", \n                 \"Sending SYNC_ACK for token={}\", *cmd.sync_token);\n\n        send_sync_ack(*cmd.sync_token);\n        waiting_sync_token = cmd.sync_token;  // Block until SYNC_CONTINUE\n\n        LOG_DEBUG(instrument_name, \"WORKER\",\n                 \"Now waiting for SYNC_CONTINUE token={}\", *waiting_sync_token);\n    }\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#sending-sync_ack","title":"Sending SYNC_ACK","text":"<pre><code>// Worker sends ACK after completing sync command\nipc:: IPCMessage ack_msg;\nack_msg.type = ipc::IPCMessage::Type:: SYNC_ACK;\nack_msg.id = msg. id;\nack_msg. sync_token = cmd.sync_token. value();\nack_msg.payload_size = 0;\n\nipc_queue-&gt;send(ack_msg, std::chrono::milliseconds(1000));\n</code></pre>"},{"location":"SYNCHRONIZATION/#instrumentworkerproxy-server-side","title":"InstrumentWorkerProxy (Server Side)","text":"<p>File: <code>src/server/InstrumentWorkerProxy.cpp</code></p>"},{"location":"SYNCHRONIZATION/#handling-sync_ack","title":"Handling SYNC_ACK","text":"<pre><code>void InstrumentWorkerProxy::handle_sync_ack_message(const ipc::IPCMessage &amp;msg) {\n    uint64_t sync_token = msg.sync_token;\n\n    LOG_DEBUG(instrument_name_, \"PROXY\", \"Received SYNC_ACK for token={}\", sync_token);\n\n    // Notify sync coordinator\n    bool barrier_complete = sync_coordinator_.handle_ack(sync_token, instrument_name_);\n\n    if (barrier_complete) {\n        LOG_INFO(instrument_name_, \"PROXY\",\n                 \"Sync barrier {} complete, broadcasting SYNC_CONTINUE\", sync_token);\n\n        // Send SYNC_CONTINUE to this worker\n        send_sync_continue(sync_token);\n    }\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#broadcasting-sync_continue","title":"Broadcasting SYNC_CONTINUE","text":"<pre><code>void InstrumentWorkerProxy::send_sync_continue(uint64_t sync_token) {\n    if (! ipc_queue_ || !ipc_queue_-&gt;is_valid()) {\n        LOG_WARN(instrument_name_, \"PROXY\", \"Cannot send SYNC_CONTINUE, queue invalid\");\n        return;\n    }\n\n    ipc::IPCMessage msg;\n    msg.type = ipc::IPCMessage::Type::SYNC_CONTINUE;\n    msg.id = 0;\n    msg.sync_token = sync_token;\n    msg.payload_size = 0;\n\n    bool sent = ipc_queue-&gt;send(msg, std::chrono::milliseconds(1000));\n\n    if (sent) {\n        LOG_DEBUG(instrument_name_, \"PROXY\", \"Sent SYNC_CONTINUE token={}\", sync_token);\n    } else {\n        LOG_ERROR(instrument_name_, \"PROXY\", \"Failed to send SYNC_CONTINUE token={}\", sync_token);\n    }\n}\n</code></pre>"},{"location":"SYNCHRONIZATION/#usage-in-lua-scripts","title":"Usage in Lua Scripts","text":""},{"location":"SYNCHRONIZATION/#basic-parallel-block","title":"Basic Parallel Block","text":"<pre><code>-- Set multiple voltages simultaneously\ncontext:parallel(function()\n    context:call(\"DAC1:1.SetVoltage\", 1.5)\n    context:call(\"DAC2:1.SetVoltage\", 2.0)\n    context:call(\"DAC3:1.SetVoltage\", 0.5)\nend)\n\n-- All voltages are now set\ncontext:log(\"All DACs synchronized\")\n</code></pre>"},{"location":"SYNCHRONIZATION/#parallel-read-and-write","title":"Parallel Read and Write","text":"<pre><code>-- Set outputs and measure inputs simultaneously\ncontext:parallel(function()\n    -- Set DACs\n    context:call(\"DAC1.SetVoltage\", 1.0)\n    context:call(\"DAC2.SetVoltage\", 2.0)\n\n    -- Trigger measurements\n    context:call(\"DMM1.Trigger\")\n    context:call(\"DMM2.Trigger\")\nend)\n\n-- Now fetch results (sequential, after sync point)\nlocal v1 = context:call(\"DMM1.FetchResult\")\nlocal v2 = context:call(\"DMM2.FetchResult\")\n\ncontext:log(string.format(\"Results: %. 6f, %.6f\", v1, v2))\n</code></pre>"},{"location":"SYNCHRONIZATION/#nested-loops-with-sync","title":"Nested Loops with Sync","text":"<pre><code>for outer = 1, 10 do\n    -- Set outer loop parameter\n    context:call(\"DAC1.SetVoltage\", outer * 0.1)\n\n    for inner = 1, 20 do\n        -- Inner loop in parallel\n        context:parallel(function()\n            context:call(\"DAC2.SetVoltage\", inner * 0.05)\n            context:call(\"DAC3.SetVoltage\", inner * 0.02)\n        end)\n\n        -- Measure after sync\n        local measurement = context:call(\"DMM1.Measure\")\n        save_data(outer, inner, measurement)\n    end\nend\n</code></pre>"},{"location":"SYNCHRONIZATION/#conditional-parallel-execution","title":"Conditional Parallel Execution","text":"<pre><code>function set_voltages_parallel(dacs, voltages)\n    context:parallel(function()\n        for i, dac_name in ipairs(dacs) do\n            context:call(dac_name .. \".SetVoltage\", voltages[i])\n        end\n    end)\nend\n\n-- Use the function\nset_voltages_parallel({\"DAC1\", \"DAC2\", \"DAC3\"}, {1.0, 2.0, 3.0})\n</code></pre>"},{"location":"SYNCHRONIZATION/#performance","title":"Performance","text":""},{"location":"SYNCHRONIZATION/#overhead-measurements","title":"Overhead Measurements","text":"<p>Tested on Intel i7, Ubuntu 20.04, 3 instruments:</p> Component Time Notes Sync token generation 10 ns Atomic increment Barrier registration 2 \u00b5s Map insertion + mutex Command dispatch (3 cmds) 300 \u00b5s IPC + serialization Worker execution 5-50 ms Hardware dependent ACK collection (3 ACKs) 150 \u00b5s IPC receive SYNC_CONTINUE broadcast 150 \u00b5s IPC send to 3 workers Total sync overhead ~600 \u00b5s Excluding hardware"},{"location":"SYNCHRONIZATION/#scaling","title":"Scaling","text":"# Instruments Sync Overhead Notes 2 400 \u00b5s Baseline 5 800 \u00b5s Linear scaling 10 1.5 ms Still sub-millisecond 20 3 ms Practical limit <p>Conclusion:  Sync overhead is negligible compared to instrument response times (typically 1-100ms).</p>"},{"location":"SYNCHRONIZATION/#throughput","title":"Throughput","text":"<p>For repeated measurements with parallel execution:</p> <pre><code>for i = 1, 1000 do\n    context:parallel(function()\n        context:call(\"DAC1.Set\", i * 0.001)\n        context:call(\"DAC2.Set\", i * 0.002)\n    end)\n    measure()\nend\n</code></pre> <p>Measured throughput: ~500 iterations/second (2ms per iteration)</p> <ul> <li>Hardware settling:  ~1ms</li> <li>Sync overhead: ~0.5ms</li> <li>Measurement:  ~0.5ms</li> </ul>"},{"location":"SYNCHRONIZATION/#debugging","title":"Debugging","text":""},{"location":"SYNCHRONIZATION/#enable-sync-logging","title":"Enable Sync Logging","text":"<pre><code>instrument-server measure dc script.lua --log-level debug\n</code></pre>"},{"location":"SYNCHRONIZATION/#log-patterns","title":"Log Patterns","text":"<p>Look for these in <code>instrument_server.log</code>:</p> <pre><code>[SYNC] [REGISTER] Registered barrier token=42 with 3 instruments\n[PROXY] [DAC1] Received SYNC_ACK for token=42\n[PROXY] [DAC2] Received SYNC_ACK for token=42\n[PROXY] [DAC3] Received SYNC_ACK for token=42\n[SYNC] [COMPLETE] Barrier 42 complete, all 3 instruments ACKed\n[PROXY] [DAC1] Sent SYNC_CONTINUE token=42\n[PROXY] [DAC2] Sent SYNC_CONTINUE token=42\n[PROXY] [DAC3] Sent SYNC_CONTINUE token=42\n</code></pre>"},{"location":"SYNCHRONIZATION/#worker-logs","title":"Worker Logs","text":"<p>Check worker logs for sync state:</p> <pre><code>tail -f worker_DAC1.log\n</code></pre> <pre><code>[WORKER] [DAC1] Received command: SetVoltage (sync=42)\n[WORKER] [DAC1] Command executed:  result=0 success=true\n[WORKER] [DAC1] Sending SYNC_ACK for token=42\n[WORKER] [DAC1] Now waiting for SYNC_CONTINUE token=42\n[WORKER] [DAC1] Received SYNC_CONTINUE for token=42, proceeding\n</code></pre>"},{"location":"SYNCHRONIZATION/#timing-analysis","title":"Timing Analysis","text":"<p>Add timing logs to scripts:</p> <pre><code>local start = os.clock()\n\ncontext:parallel(function()\n    context:call(\"DAC1.Set\", 1.0)\n    context:call(\"DAC2.Set\", 2.0)\n    context:call(\"DAC3.Set\", 3.0)\nend)\n\nlocal elapsed = os. clock() - start\ncontext:log(string.format(\"Parallel block took %.3f ms\", elapsed * 1000))\n</code></pre>"},{"location":"SYNCHRONIZATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"SYNCHRONIZATION/#problem-parallel-block-never-completes","title":"Problem: Parallel block never completes","text":"<p>Symptoms:</p> <ul> <li>Script hangs in <code>parallel()</code> block</li> <li>No error messages</li> <li>Workers show \"waiting for SYNC_CONTINUE\"</li> </ul> <p>Diagnosis:</p> <pre><code># Check if all instruments are running\ninstrument-server list\n\n# Check worker logs\ntail -f worker_*. log | grep SYNC\n</code></pre> <p>Cause: One instrument in parallel block is not running or crashed</p> <p>Solution:</p> <pre><code># Restart missing instrument\ninstrument-server start configs/missing_instrument.yaml\n\n# Or remove it from parallel block\n</code></pre>"},{"location":"SYNCHRONIZATION/#problem-commands-execute-sequentially-despite-parallel","title":"Problem: Commands execute sequentially despite parallel()","text":"<p>Symptoms:</p> <ul> <li>Parallel block slow (sum of individual times)</li> <li>Logs show sequential execution</li> </ul> <p>Diagnosis: Check if commands target same instrument:</p> <pre><code>-- WRONG: Both target DAC1, executes sequentially\ncontext:parallel(function()\n    context:call(\"DAC1:1.Set\", 1.0)\n    context:call(\"DAC1:2.Set\", 2.0)  -- Same instrument!\nend)\n</code></pre> <p>Solution: Parallel only works across different instruments:</p> <pre><code>-- CORRECT: Different instruments, true parallel\ncontext:parallel(function()\n    context:call(\"DAC1:1.Set\", 1.0)\n    context:call(\"DAC2:1.Set\", 2.0)  -- Different instrument\nend)\n</code></pre>"},{"location":"SYNCHRONIZATION/#problem-sync_ack-timeout","title":"Problem: SYNC_ACK timeout","text":"<p>Symptoms:</p> <pre><code>[SYNC] [ACK] Barrier 42 timeout, missing ACKs from:  DAC2\n</code></pre> <p>Cause: Worker crashed or command failed</p> <p>Diagnosis:</p> <pre><code># Check worker status\ninstrument-server status DAC2\n\n# Check worker log\ntail -f worker_DAC2.log\n</code></pre> <p>Solution:</p> <pre><code># Restart worker\ninstrument-server stop DAC2\ninstrument-server start configs/dac2.yaml\n</code></pre>"},{"location":"SYNCHRONIZATION/#problem-incorrect-timing-despite-sync","title":"Problem: Incorrect timing despite sync","text":"<p>Symptoms:</p> <ul> <li>Measurements show timing skew</li> <li>Sync logs show correct operation</li> </ul> <p>Cause: Hardware settling time differences</p> <p>Solution:  Add explicit delays:</p> <pre><code>context:parallel(function()\n    context:call(\"DAC1.Set\", 1.0)\n    context:call(\"DAC2.Set\", 2.0)\nend)\n\n-- Wait for settling (all instruments past sync point)\nos.execute(\"sleep 0.01\")  -- 10ms settling\n\n-- Now measure\nlocal result = context:call(\"DMM1.Measure\")\n</code></pre>"},{"location":"SYNCHRONIZATION/#advanced-topics","title":"Advanced Topics","text":""},{"location":"SYNCHRONIZATION/#multiple-parallel-blocks","title":"Multiple Parallel Blocks","text":"<p>Sync tokens are independent - multiple blocks can be in flight:</p> <pre><code>-- Outer loop\nfor i = 1, 100 do\n    context:parallel(function()  -- token=1, 2, 3, ... \n        context:call(\"DAC1.Set\", i)\n        context:call(\"DAC2.Set\", i * 2)\n    end)\n\n    -- Inner loop (different sync)\n    for j = 1, 10 do\n        context:parallel(function()  -- token=101, 102, ... \n            context:call(\"DAC3.Set\", j)\n            context:call(\"DAC4.Set\", j * 3)\n        end)\n    end\nend\n</code></pre>"},{"location":"SYNCHRONIZATION/#partial-instrument-participation","title":"Partial Instrument Participation","text":"<p>Not all instruments need to participate in every sync:</p> <pre><code>-- Only DAC1 and DAC2 synced\ncontext:parallel(function()\n    context:call(\"DAC1.Set\", 1.0)\n    context:call(\"DAC2.Set\", 2.0)\nend)\n\n-- DAC3 operates independently\ncontext:call(\"DAC3.Set\", 3.0)\n\n-- Different sync group\ncontext:parallel(function()\n    context:call(\"DAC3.Set\", 3.5)\n    context:call(\"DAC4.Set\", 4.0)\nend)\n</code></pre>"},{"location":"SYNCHRONIZATION/#error-handling-in-parallel-blocks","title":"Error Handling in Parallel Blocks","text":"<p>Individual command failures don't block sync:</p> <pre><code>context:parallel(function()\n    context:call(\"DAC1.Set\", 1.0)     -- Succeeds\n    context:call(\"DAC2.Set\", 999.0)   -- Fails (out of range)\n    context:call(\"DAC3.Set\", 3.0)     -- Succeeds\nend)\n\n-- Block completes, but DAC2 command failed\n-- Check individual instrument status if needed\n</code></pre>"},{"location":"SYNCHRONIZATION/#see-also","title":"See Also","text":"<ul> <li>Architecture - System design</li> <li>CLI Usage - Running measurements</li> <li>Main README - Getting started</li> </ul>"}]}